<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>后端 on Fourleaf Blog</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/</link><description>Recent content in 后端 on Fourleaf Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 29 Aug 2022 10:12:23 +0800</lastBuildDate><atom:link href="https://zhujianghan.github.io/zjh-blog/posts/backend/index.xml" rel="self" type="application/rss+xml"/><item><title>Interview | Find the only number in a list</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/interview_find_the_only_number_in_a_list/</link><pubDate>Mon, 29 Aug 2022 10:12:23 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/interview_find_the_only_number_in_a_list/</guid><description>题: 有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？ 来源: 李文周 Go语言基础之运算符
利用 ^ 二进位异或 运算符
func findTheOnlyNumber(nums []int) (res int) { for index, num := range nums { if index == 0 { res = num } else { res = res ^ num } } return }</description></item><item><title>Interview | Number of Chinese in a String</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/interview_number-of-chinese-in-a-string/</link><pubDate>Fri, 26 Aug 2022 16:18:04 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/interview_number-of-chinese-in-a-string/</guid><description>题目: 编写代码统计出字符串&amp;quot;hello沙河小王子&amp;quot;中汉字的数量 题目来源: 李文周blog: Go语言基础之基本数据类型
tips:
字符串用 for 遍历, str[i] 的值是 byte(uint8) 类型, 且下标 i 是连续的, 从 0 到 len(str) 字符串用 for range 遍历, index,value 的值是 rune(int32) 类型, 下标不一定是连续的, 碰到中文只会出现中文的首下标, 然后跳到下一个 rune 字符 func getChineseCharNumInAString(str string) (num int) { for i, r := range str { if byte(r) == str[i] { continue } num++ } return num }</description></item><item><title>Buffer-String()-和-Buffer-String()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/buffer-string-%E5%92%8C-buffer-string/</link><pubDate>Thu, 16 Jun 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/buffer-string-%E5%92%8C-buffer-string/</guid><description>b1 := bytes.Buffer{} // 非指针 b2 := bytes.NewBuffer([]byte{}) // 指针 b3 := &amp;amp;bytes.Buffer{} // 指针, 等同于 b2 b1.WriteString(&amp;#34;abc&amp;#34;) b2.WriteString(&amp;#34;abc&amp;#34;) fmt.Println(b1) // {[97 98 99] 0 0} fmt.Println(b1.String()) // abc fmt.Println(b2) // abc 原因: *Buffer 有方法 String(), Buffer 没有 String() 方法.
fmt.Println(b1), 就是 fmt 将 b1 按普通结构体进行输出: 分别输出各项 fmt.Println(b1.String()), 调用了 *Buffer 的 String() 方法 fmt.Println(b2), 自动调用 *Buffer 的 String() 方法 参考自 stackoverflow</description></item><item><title>gin-middleware-注意事项</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/gin-middleware-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Tue, 07 Jun 2022 14:49:09 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/gin-middleware-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>1. gin middleware 如果要中止后面中间件及所有程序的执行, 需要使用 c.Abort() + return 其中 Abort 会中止其后的中间件及页面处理程序, 而不会中止当前中间件函数内的余下程序, 使用 return 来中止当前中间件内后部的程序 func RejectMethodsExceptGet() gin.HandlerFunc { rejectMethods := map[string]struct{}{ &amp;#34;POST&amp;#34;: {}, &amp;#34;DELETE&amp;#34;: {}, &amp;#34;PUT&amp;#34;: {}, &amp;#34;PATCH&amp;#34;: {}, } return func(c *gin.Context) { if _, exist := rejectMethods[c.Request.Method]; exist { c.AbortWithStatusJSON(403, gin.H{ &amp;#34;err_msg&amp;#34;: &amp;#34;invalid method&amp;#34;, }) return } c.Next() } } 2. 中间件 Use 需要写在路由注册之前, 否则将不对之前注册的路由起作用 r := gin.New() r.Use(RejectMethodsExceptGet()) r.GET(&amp;#34;/test&amp;#34;, func(c *gin.Context) { example := c.MustGet(&amp;#34;example&amp;#34;).(string) // it would print: &amp;#34;12345&amp;#34; log.</description></item><item><title>go-routine-使用外部变量问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-routine-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 26 Apr 2022 10:28:36 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-routine-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</guid><description>for i := 0; i &amp;lt; 10; i++ { go func() { fmt.Println(i) } } time.Sleep(time.Second) // 10,10,10,10,... 使用 go vet 检查
// 修改 for i := 0; i &amp;lt; 10; i++ { go func() { i2 := i fmt.Println(i2) } } // 或者(推荐) for i := 0; i &amp;lt; 10; i++ { go func(i int) { fmt.Println(i) }(i) } time.Sleep(time.Second) 参考 https://www.jianshu.com/p/e5f328819d4b</description></item><item><title>$_ENV-&amp;-getenv()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/_env--getenv/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/_env--getenv/</guid><description>php 中 $_ENV &amp;amp; getenv() 获取的是环境变量, 如 windows 中 高级系统设置中的环境变量 或 linux 中 export 设置
getenv() 或 $_ENV 获取的是(系统)环境变量, 而不是 .env 文件.
在默认variables_order = &amp;quot;GPCS&amp;quot; 时, laravel 中使用 $_ENV 不能获取到(系统)环境变量, 但是可以获取到 .env 中的变量, 是因为 laravel 在初始化时使用 phpdotenv 将 .env 中的值添加到 $_ENV 中了.
另外 laravel 中 getenv() 本来就可以获取到(系统)环境变量, 也可以获取到 .env 文件中的设置的环境变量, 是因为 laravel(phpdotenv) 用 putenv() 设置了请求期间内有效的环境变量.
ini_set() 配置可修改范围 参考php手册 laravel 初始化 dotenv 参考文章 Laravel ENV—— 环境变量的加载与源码解析</description></item><item><title>dingo-api-返回-response--array()--setStatusCode()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/dingo-api-%E8%BF%94%E5%9B%9E-response--array--setstatuscode/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/dingo-api-%E8%BF%94%E5%9B%9E-response--array--setstatuscode/</guid><description>phpstorm 对 $this-&amp;gt;response-&amp;gt;item(***)-&amp;gt;setStatusCode(***) 中的 item() 和 setStatusCode() 都有提示,
找了下 Dingo\Api\Routing\Helpers trait类 中的 __call() 方法
public function __call($method, $parameters) { if (method_exists($this-&amp;gt;response(), $method) || $method == &amp;#39;array&amp;#39;) { return call_user_func_array([$this-&amp;gt;response(), $method], $parameters); } throw new ErrorException(&amp;#39;Undefined method &amp;#39;.get_class($this).&amp;#39;::&amp;#39;.$method); } 意为调用 $this-&amp;gt;response() 类( Factory类)的 $method (也就是 array() 方法), 并将 $parameters 作为参数 也就是 Factory 类的 array() 方法, 没想到 在 Factory 类中, array() 方法也是通过 __call() 魔术方法调用的&amp;hellip;
另: call_user_func_array() 方法: 调用回调函数，并把一个数组参数作为回调函数的参数
如果调用的方法是一个类方法, 那么用 数组将 类名和方法名 组合起来 [$this-&amp;gt;response(), $method] 表示回调方法</description></item><item><title>foreach-中使用-&amp;地址符时,-最后要释放-value</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/foreach-%E4%B8%AD%E4%BD%BF%E7%94%A8-%E5%9C%B0%E5%9D%80%E7%AC%A6%E6%97%B6-%E6%9C%80%E5%90%8E%E8%A6%81%E9%87%8A%E6%94%BE-value/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/foreach-%E4%B8%AD%E4%BD%BF%E7%94%A8-%E5%9C%B0%E5%9D%80%E7%AC%A6%E6%97%B6-%E6%9C%80%E5%90%8E%E8%A6%81%E9%87%8A%E6%94%BE-value/</guid><description>$arr = [1,2,3]; foreach($arr as $key=&amp;gt; &amp;amp;$value){ if ($key){ $value = $value +1; } } unset($value); // 要注意翻译 $value, 否则后面如果还要用到 $value 时, 会指向 $arr 的最后一个元素</description></item><item><title>git-创建远程分支---从远程分支拉取本地不存在的分支</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/git-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF---%E4%BB%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E6%8B%89%E5%8F%96%E6%9C%AC%E5%9C%B0%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%88%86%E6%94%AF/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/git-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF---%E4%BB%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E6%8B%89%E5%8F%96%E6%9C%AC%E5%9C%B0%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%88%86%E6%94%AF/</guid><description>原文
新建远程分支 git push origin remote_branch_name:local_branch_name // remote_branch_name 是远程分支的名字 // local_branch_name 是本地分支的名字 git branch -a // 查看所有分支(远程+本地) 删除远程分支 git push origin :remote_branch_name // 或 git push origin --delete remote_branch_name 原文
git fetch git checkout -b local_branch_name origin/remote_branch_name</description></item><item><title>go-通用-http-client-请求头</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E9%80%9A%E7%94%A8-http-client-%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E9%80%9A%E7%94%A8-http-client-%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>参考stackoverflow: adding-a-default-http-header-in-go
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) const accessToken = &amp;#34;MY_DEMO_TOKEN&amp;#34; type MyRoundTripper struct { r http.RoundTripper } func (mrt MyRoundTripper) RoundTrip(r *http.Request) (*http.Response, error) { r.Header.Add(&amp;#34;Authorization&amp;#34;, &amp;#34;Bearer: &amp;#34;+accessToken) return mrt.r.RoundTrip(r) } func main() { client := &amp;amp;http.Client{ Timeout: time.Second * 10, Transport: MyRoundTripper{r: http.DefaultTransport}, } fmt.Println(client.Get(&amp;#34;http://google.com/&amp;#34;)) }</description></item><item><title>guzzle-http-post-(json)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/guzzle-http-post-json/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/guzzle-http-post-json/</guid><description>$client = new \GuzzleHttp\Client(); $response = $client-&amp;gt;post(&amp;#39;http://xxx.com/api/login&amp;#39;, [ &amp;#39;json&amp;#39; =&amp;gt; [ &amp;#39;phone&amp;#39; =&amp;gt; &amp;#34;152xxxx1234&amp;#34;, &amp;#39;password&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34;, ] ]); $response = $client-&amp;gt;post(&amp;#39;http://xxx.com/api/login&amp;#39;, [ &amp;#39;form_params&amp;#39; =&amp;gt; [ &amp;#39;phone&amp;#39; =&amp;gt; &amp;#34;152xxxx1234&amp;#34;, &amp;#39;password&amp;#39; =&amp;gt; 123456, ] ]); 若使用 json, 则 数组中的值(不论是否数字), 都要用 引号 起来, 而 form_params 则不需要
reference</description></item><item><title>js-的遍历</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/js-%E7%9A%84%E9%81%8D%E5%8E%86/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/js-%E7%9A%84%E9%81%8D%E5%8E%86/</guid><description/></item><item><title>json-Unmarshal-如何获取-null</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/json-unmarshal-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-null/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/json-unmarshal-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-null/</guid><description>对于如下 json 和 struct, 会将 gender 解析为 false, 而实际上应为 nil, 则需要 将 struct 中的 bool 类型转为 *bool 类型
{ &amp;#34;name&amp;#34;: &amp;#34;Jim Green&amp;#34;, &amp;#34;age&amp;#34;: 15, &amp;#34;gender&amp;#34;: null } type Student struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` Name bool `json:&amp;#34;gender&amp;#34;` } 因为在 go 中指针不可以进行运算, 只能引用 对于 *bool 类型的变量, 不能直接赋值 如
var gender *bool *gender = true // panic: runtime error: invalid memory address or nil pointer dereference 而应该对非指针类型赋值, 再引用指针
var gender *bool tempGender := true gender = &amp;amp;tempGender</description></item><item><title>laravel-dispatch()-异步任务耗时长--</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-dispatch-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%80%97%E6%97%B6%E9%95%BF--/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-dispatch-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%80%97%E6%97%B6%E9%95%BF--/</guid><description>在控制器中使用 This-&amp;gt;dispatch(new Job()) 后, 接口依然耗时长.
原因是 job 类中 __contruct() 方法里操作过多(请求api等), 这一步是同步进行的. 真正 异步 执行的是 Job 类中的 handle() 方法</description></item><item><title>laravel-factory()--make()---create()-的区别</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-factory--make---create-%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-factory--make---create-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>相同点: 都是生成模型的实例
不同点: create() 同时执行了 save()方法, 保存到了数据库中; make() 只生成了模型实例</description></item><item><title>laravel-migration-`Integrity-constraint-violation-`</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-migration-integrity-constraint-violation-/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-migration-integrity-constraint-violation-/</guid><description>原因不是 约束的 key 重复了, 而是数据库中已存在数据, 且该字段重复了</description></item><item><title>laravel-定时任务不执行了--</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%B8%8D%E6%89%A7%E8%A1%8C%E4%BA%86--/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%B8%8D%E6%89%A7%E8%A1%8C%E4%BA%86--/</guid><description>linux 服务端使用 pm2 开启 php artisan queue:work 守护进程, 突然 队列不工作了.
原因可能是 代码更新后, 没有重启 任务, 所以 pm2 reload 0 即可</description></item><item><title>laravel5-5+-Package-Auto-Discovery-包自动发现</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel5-5+-package-auto-discovery-%E5%8C%85%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel5-5+-package-auto-discovery-%E5%8C%85%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0/</guid><description>转载自原文
一切的起源都是来自 composer.json ,在使用 composer 的时候，你可以在 post-autoload-dump 部分指定你想执行的脚本，比如在 Laravel 5.5 的时候，我们可以看到这样的定义：
&amp;#34;scripts&amp;#34;: { &amp;#34;post-autoload-dump&amp;#34;: [ &amp;#34;Illuminate\\Foundation\\ComposerScripts::postAutoloadDump&amp;#34;, &amp;#34;@php artisan package:discover --ansi&amp;#34; ], ... } 对于 postAutoloadDump 是很熟悉了，Laravel 之前的版本基本都有，它的工作是清理一些缓存，删除一些旧的文件。
我们的关注重点是 @php artisan package:discover ，也就是会执行 @php artisan package:discover 这个命令。
这个命令是干嘛的呢？它其实是位于Illuminate\Foundation\Console\PackageDiscoverCommand 中，主要是通过执行Illuminate\Foundation\PackageManifest 的 build() 方法来达到 发现 package 的目的。
而 PackageManifest 早就注册在 Laravel 的 Container 中，那么它可以保证每次在启动 Laravel 的时候都能使用 PackageManifest 的 build() 方法，这个 build() 方法主要的逻辑就是：
找寻 vendor/composer/installed.json 这个文件，这个文件是 composer 自己生成的，记录着每一次的 composer autoload 的 class map。
而此时，Laravel 又将这些内容映射到 extra.</description></item><item><title>middleware-gin-contrib-cors-在-301-时失效</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/middleware-gin-contrib-cors-%E5%9C%A8-301-%E6%97%B6%E5%A4%B1%E6%95%88/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/middleware-gin-contrib-cors-%E5%9C%A8-301-%E6%97%B6%E5%A4%B1%E6%95%88/</guid><description>背景: gin 配置了路由 router.GET(&amp;quot;/api/users&amp;quot;) , 添加了 cors 中间件, 但是访问 /api/users/ 时, 会返回 301 + cros 错误
原因: gin 默认打开 &amp;ldquo;RedirectTrailingSlash&amp;rdquo;, 表示自动添加(或删除) &amp;ldquo;/&amp;rdquo; 并作 301 跳转, 这时候还未进入 middleware, 所以 cors 中间件所添加的 header 不会出现在返回头中.
中间件其它现象:
c.Header(&amp;#34;before-next&amp;#34;: &amp;#34;can-be-show&amp;#34;) // 会写入到返回头 c.next() c.Header(&amp;#34;after-next&amp;#34;: &amp;#34;won&amp;#39;t be returned&amp;#34;) // 不会出现在返回头中 解决办法:
在 gin 路由中同时添加 带 / 和不带 / 的路由, 工作量大, 且 ugly ❌ 使用 nginx 在 go-web 程序外部直接全部带上 cors 头 ✅</description></item><item><title>notes--基于-Composer-的-PHP-模块化开发</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/notes--%E5%9F%BA%E4%BA%8E-composer-%E7%9A%84-php-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/notes--%E5%9F%BA%E4%BA%8E-composer-%E7%9A%84-php-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</guid><description>笔记来源 overtrue: 基于 Composer 的 PHP 模块化开发
1. what &amp;amp; why composer 是 php 版本的版本控制工具, 如 js 里的 npm, go 里的 mod.
1.1 composer.json 的组成 基础字段 name, description, keywords, license 依赖 require, require-dev 自动加载: autoload, autoload-dev PSR-4 PSR-0 classmate files 其它 scripts, minimum-stability, bin, repositories, support, config 其中, 若是一个项目, name 表示 project name, 若是一个包, name 表示 package name
在没有 composer 之前, 靠人工复制粘贴代码, 存在代码安全及 repeat yourself 的问题
1.2 版本号的组成 Major.Minor.Patch
major: 大的功能变更, 不向后兼容 minor: 新增功能, 向后兼容 patch: 补丁, 向后兼容, 修复 bug 1.</description></item><item><title>php-类方法的连接调用-$this--where()--select()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B0%83%E7%94%A8-this--where--select/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B0%83%E7%94%A8-this--where--select/</guid><description>这种类方法最后都返回了 $this, 从而能连续调用;
至于中间的方法, 通过类属性将值保存起来, 可供后续方法继续使用</description></item><item><title>PHP-三大设计模式--单例&amp;工厂&amp;注册树</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%B3%A8%E5%86%8C%E6%A0%91/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%B3%A8%E5%86%8C%E6%A0%91/</guid><description>&amp;lt;?php // 单例模式(三私一公) class Site{ protected static $_instance; protected function __construct(){ return self::$_instance; } protected function __clone(){ } public static function getSingleton(){ if(! (self::$_instance instanceof self)){ self::$_instance = new self(); } return self::$_instance; } } // 工厂模式 class Factory{ public static function create($className){ return $className::getSingleton(); } } // 注册树模式 class Container{ protected static $object = []; public static function set($alias, $obj){ self::$object[$alias] = $obj; } public static function get($alias){ return self::$object[$alias]; } public static function _unset($alias){ unset(self::$object[$alias]); } Container::set(&amp;#39;site&amp;#39;, Factory::create(&amp;#39;Site&amp;#39;));// 把单一对象实例挂到注册树上 $site = Container::get(&amp;#39;site&amp;#39;);// 从注册树中获取对象</description></item><item><title>php-图片处理扩展包-intervention-image-在-win-中使用遇到问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E6%89%A9%E5%B1%95%E5%8C%85-intervention-image-%E5%9C%A8-win-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E6%89%A9%E5%B1%95%E5%8C%85-intervention-image-%E5%9C%A8-win-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</guid><description>环境: laravel-admin + laragon 使用 intervention/image 时, 报错 : encodeing format(tmp) is not suppoerted 原因: intervention/image 这个包不与 windows 兼容 临时解决办法: 修改 包文件 AbstractEncoder.php 原文见 github laravel-admin issue</description></item><item><title>php-重写(override,-覆盖)-和-重载(overload)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E9%87%8D%E5%86%99override-%E8%A6%86%E7%9B%96-%E5%92%8C-%E9%87%8D%E8%BD%BDoverload/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E9%87%8D%E5%86%99override-%E8%A6%86%E7%9B%96-%E5%92%8C-%E9%87%8D%E8%BD%BDoverload/</guid><description> 重写: 子类继承父类时, 重写了方法 重载: 传统意义上的重载(如java), 指一个类中存在多个同名的方法, 但接收参数不一样, php 不支持这样的写法 php 提供的 overloading(重载), 指的是 动态地创建类属性和方法, 通过 魔术方法 来实现</description></item><item><title>phpoffice---phpword-写入文件不可打开</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/phpoffice---phpword-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8D%E5%8F%AF%E6%89%93%E5%BC%80/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/phpoffice---phpword-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8D%E5%8F%AF%E6%89%93%E5%BC%80/</guid><description>使用 phpword 的模板写入字符串时, 最后生成的文件打开失败.
这可能是因为 写入的文件内容没有 做 htmlspecialchars 处理, 而 docx 的 xml 不允许 &amp;amp;, &amp;lsquo;, &amp;ldquo;, &amp;lt;, &amp;gt; 字符, 这几样需要进行转义处理.</description></item><item><title>php中-utf-8-还是-utf8--</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E4%B8%AD-utf-8-%E8%BF%98%E6%98%AF-utf8--/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E4%B8%AD-utf-8-%E8%BF%98%E6%98%AF-utf8--/</guid><description>utf8、utf-8 和 UTF-8 的区别如下：
一、“UTF-8”这是标准写法，在PHP和HTML中设置编码，统一写成“UTF-8”。 举例： PHP中 —— HTML中　——　二、“utf8”、“utf-8”和“UTF8”只是在window中不区分大小写的写法而已，一般程序能识别，但也有例外。例如简写的“UTF8”或“utf8”在ie浏览器里不识别。
三、数据库命令模式中，必须写成“utf8”，因为MySQL的命令模式中只能识别“utf8”，比如：PHP程序中可以写： 结论：MySQL操作使用“utf8” 【mysql_query(set names utf8)】，其他一律使用“UTF-8”。
原文见: https://blog.csdn.net/ahjxhy2010/article/details/79722997</description></item><item><title>supervisor-unix----tmp-supervisor-sock-no-such-file</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/supervisor-unix----tmp-supervisor-sock-no-such-file/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/supervisor-unix----tmp-supervisor-sock-no-such-file/</guid><description>[root@iZm5e09hymnzdmgx3964zgZ etc]# cat -n supervisord.conf | grep /tmp -- 22 [unix_http_server] 23 ;file=/tmp/supervisor.sock ; the path to the socket file 24 file=/var/run/supervisor.sock ; the path to the socket file -- 45 [supervisord] 46 ;logfile=/tmp/supervisord.log ; main log file; default $CWD/supervisord.log 47 logfile=/var/log/supervisord.log ; main log file; default $CWD/supervisord.log -- 50 loglevel=info ; log level; default info; others: debug,warn,trace 51 ;pidfile=/tmp/supervisord.pid ; supervisord pidfile; default supervisord.pid 52 pidfile=/var/run/supervisord.pid ; supervisord pidfile; default supervisord.</description></item><item><title>thinkphp5-0-解决跨域</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-0-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-0-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/</guid><description>在 public/index.php 中加入
header(&amp;#34;Access-Control-Allow-Origin:*&amp;#34;); header(&amp;#34;Access-Control-Allow-Credentials: true&amp;#34;); header(&amp;#34;Access-Control-Allow-Methods:GET, POST, OPTIONS, DELETE&amp;#34;); header(&amp;#34;Access-Control-Allow-Headers:Request-Timestamp,Access-Token,Refresh-Token,Access-Control-Allow-Origin,DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type, Accept-Language, Origin, Accept-Encoding&amp;#34;); if(strtolower($_SERVER[&amp;#39;REQUEST_METHOD&amp;#39;]) === &amp;#39;options&amp;#39;){ exit; } 貌似 tp5.1 中路由可以设置允许跨域
Route::get(&amp;#39;new/:id&amp;#39;, &amp;#39;News/read&amp;#39;) -&amp;gt;ext(&amp;#39;html&amp;#39;) -&amp;gt;allowCrossDomain();</description></item><item><title>tp5-0-中的-volist-中的循环变量-$i</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-0-%E4%B8%AD%E7%9A%84-volist-%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F-i/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-0-%E4%B8%AD%E7%9A%84-volist-%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F-i/</guid><description>// 输出循环变量： {volist name=&amp;#34;list&amp;#34; id=&amp;#34;vo&amp;#34; key=&amp;#34;k&amp;#34; } {$k}.{$vo.name} {/volist} //如果没有指定key属性的话，默认使用循环变量i，例如： {volist name=&amp;#34;list&amp;#34; id=&amp;#34;vo&amp;#34; } {$i}.{$vo.name} {/volist} -这里的索引是从 1 开始的, 而不是从 0 开始</description></item><item><title>tp5-1-的依赖注入,-服务容器,-facade</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-1-%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8-facade/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-1-%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8-facade/</guid><description>在一个类中 实例化另外一个类, 就是依赖性强, 耦合度高, 在 tp5.1 中 可使用 依赖注入 来解耦 class A { public function hello(){ echo &amp;#39;hello&amp;#39;; } } class B { public function sayHello(){ $a = new A(); $a-&amp;gt;hello(); } } class C { // 依赖注入的用法 public function sayHello(A $a){ $a-&amp;gt;hello(); } } 进一步使用 依赖容器 container 来解耦 容器就是一个装有各种类的对象的仓库, 然后通过 依赖容器 来实现对象的调用
最后还可以使用 facade 封装各个类(对象) 的方法, 形成对外的统一方法, 从而使用者(开发者) 无需关心调用的是哪个类的哪个方法, ( 而统一使用的是 facade 类的方法)</description></item><item><title>tp5-1-和-laravel-中的-facade-门面</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-1-%E5%92%8C-laravel-%E4%B8%AD%E7%9A%84-facade-%E9%97%A8%E9%9D%A2/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-1-%E5%92%8C-laravel-%E4%B8%AD%E7%9A%84-facade-%E9%97%A8%E9%9D%A2/</guid><description> facade 的作用是把 类(动态)方法 当作 静态方法 使用; 简称 静态代理
&amp;lt;?php class Demo { public function index(){ echo &amp;#39;hello world&amp;#39;; // echo __METHOD__; } } class DemoFacade { public static function __callStatic($name, $arguments) { $demo = new Demo(); $demo-&amp;gt;$name(); } } DemoFacade::index();// hello world</description></item><item><title>tp5-在模板(或php文件中)中获取当前的控制器名</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-%E5%9C%A8%E6%A8%A1%E6%9D%BF%E6%88%96php%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%8D/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-%E5%9C%A8%E6%A8%A1%E6%9D%BF%E6%88%96php%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%8D/</guid><description/></item><item><title>vue-router-push-后页面位置不是在顶部</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/vue-router-push-%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%BD%8D%E7%BD%AE%E4%B8%8D%E6%98%AF%E5%9C%A8%E9%A1%B6%E9%83%A8/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/vue-router-push-%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%BD%8D%E7%BD%AE%E4%B8%8D%E6%98%AF%E5%9C%A8%E9%A1%B6%E9%83%A8/</guid><description>原文见: https://blog.csdn.net/M_SSY/article/details/82850517
解决办法: 在 router/index.js 中 new router 时, 加入如下代码
scrollBehavior(to, from, savedPosition) { return {x: 0, y: 0 } }</description></item><item><title>不间断空格-none-breaking-space-(-u00a0)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%8D%E9%97%B4%E6%96%AD%E7%A9%BA%E6%A0%BC-none-breaking-space--u00a0/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%8D%E9%97%B4%E6%96%AD%E7%A9%BA%E6%A0%BC-none-breaking-space--u00a0/</guid><description>从网上复制的一些文本可能含有特殊字符, 不间断空格(unicode 编码为 \u00a0)就是一种, 效果与 &amp;rsquo; &amp;rsquo; 普通空格类似, 但有不同. 不同: 对英文单词间使用普通空格, 会自动换行; 使用不间断空格连接的单词会被认为是一个单词而直接全部换到下一行, 这在 html 也是同样的效果. 在 php 中使用 普通空格替换 不间断空格的方式
$str = &amp;#34;a a a&amp;#34;; $str = str_replace(chr( 194 ) . chr( 160 ), &amp;#34; &amp;#34;, $str); 参考自stackoverflow</description></item><item><title>帝国cms-1条信息如何实现多个内容页--</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcms-1%E6%9D%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%86%85%E5%AE%B9%E9%A1%B5--/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcms-1%E6%9D%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%86%85%E5%AE%B9%E9%A1%B5--/</guid><description>需要如图: &amp;lsquo;曲线救国&amp;rsquo; 路线: 依然是一个内容页模板, 但是 聚集三个页面的内容, 比如分成三个 div, 通过js 默认第一个 div 显示, 另两个不显示, 然后点击哪个 div, 哪个 div 显示, 其它的隐藏</description></item><item><title>帝国cms(v7-5)-在内容模板中使用-truetime-字段</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcmsv7-5-%E5%9C%A8%E5%86%85%E5%AE%B9%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8-truetime-%E5%AD%97%E6%AE%B5/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcmsv7-5-%E5%9C%A8%E5%86%85%E5%AE%B9%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8-truetime-%E5%AD%97%E6%AE%B5/</guid><description>truetime 是真实发布时间, 也就是后台 mysql 执行 insert 的时间; lastdotime 是真实更新时间, 也就是后台 mysql 执行 update 的时间; newstime 是发布时间, 由用户自定义, 在新增信息时, 表单中自行填写;
// 在模板中直接使用 $nvainfor 数组进行调用, 比如: &amp;lt;br&amp;gt;navinfor[id]-&amp;lt;?=$navinfor[id]?&amp;gt; &amp;lt;br&amp;gt;navinfor[content]-&amp;lt;?=$navinfor[content]?&amp;gt; &amp;lt;br&amp;gt;navinfor[newstime]-&amp;lt;?=$navinfor[newstime]?&amp;gt; &amp;lt;br&amp;gt;navinfor[truetime]-&amp;lt;?=$navinfor[truetime]?&amp;gt; &amp;lt;br&amp;gt;navinfor[lastdotime]-&amp;lt;?=$navinfor[lastdotime]?&amp;gt; ps: 使用 $navinfor 可以访问当前记录(1条)的全部字段信息, 使用 [!&amp;ndash;id&amp;ndash;] 方式只能访问到部分信息 见: http://www.phome.net/doc/manual/template/
原文见: http://www.phome.net/doc/manual/template/html/other.html#q17</description></item><item><title>如何减少-if---else----甚至-switch-的使用</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-if---else----%E7%94%9A%E8%87%B3-switch-%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-if---else----%E7%94%9A%E8%87%B3-switch-%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>需求: $str = &amp;#39;1,3,5&amp;#39;; // 变成 &amp;#39;abc,ghi,mno&amp;#39; $arr = [ [ &amp;#39;id&amp;#39;=&amp;gt;1, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;abc&amp;#39; ], [ &amp;#39;id&amp;#39;=&amp;gt;2, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;def&amp;#39; ], [ &amp;#39;id&amp;#39;=&amp;gt;3, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;ghi&amp;#39; ], [ &amp;#39;id&amp;#39;=&amp;gt;4, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;jkl&amp;#39; ], [ &amp;#39;id&amp;#39;=&amp;gt;5, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;mno&amp;#39; ], ]; 使用 if..else 或 switch 方法可以完成
现考虑不使用这两种方式作法:
思路: 把下面的 id 值作为键, name 值作为值, 重新构成一个数组 $arr2, 从 $str 中获取数字 如1, 使用 $arr2[&amp;lsquo;1&amp;rsquo;] 来获取对应的 name
php解法: // 1. 把当前 $arr 转成 目标数组 $arr2 $arr2 = []; foreach ($arr as $v) { $arr2[$v[&amp;#39;id&amp;#39;]] = $v[&amp;#39;name&amp;#39;]; } $str_to_arr = implode(&amp;#39;,&amp;#39;, $str);// [1,3,5] $str_to_arr = array_map(function(value){ return $arr2[&amp;#39;value&amp;#39;]; }) $str2 = join(&amp;#39;,&amp;#39;, $str_to_arr); JS 解法: js 只支持索引数组, 不支持关联数组, 但是 ES6 的 Map 对象支持任意的键或值 var str = &amp;#39;1,3,5&amp;#39;; var data = [ { id: 1, name: &amp;#39;中国&amp;#39; }, { id: 2, name: &amp;#39;美国&amp;#39; }, { id: 3, name: &amp;#39;日本&amp;#39; }, { id: 4, name: &amp;#39;韩国&amp;#39; }, { id: 5, name: &amp;#39;俄国&amp;#39; } ]; console.</description></item><item><title>使用-gregwar-captcha-生成固定字符的验证码</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%BD%BF%E7%94%A8-gregwar-captcha-%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%BD%BF%E7%94%A8-gregwar-captcha-%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81/</guid><description>使用 gregwar/captcha 可以方便地生成验证码图片(直接输出或 base64)
$builder = new CaptchaBuilder; $builder-&amp;gt;build(); $text = $builder-&amp;gt;getPhrase(); // 验证码文本 $pic = $builder-&amp;gt;inline();// base64 captcha 现如今在 laravel 本地环境中(非 production), 不想每次生成新的要去图片查验的验证码, 查看文档, 说是 &amp;ldquo;直接使用 $builder = new CaptchaBuilder('12345')&amp;rdquo;, 其中的 12345 (phrase) 必须为 string 但是这样再使用 $builder-&amp;gt;inline() 会报错, 无法生成验证码图片
经过查看 CaptchaBuilder.php 类文件, 比较两种方式有什么差别() 可以发现, 随机生成验证码我多走了一步 $builder-&amp;gt;build(), 而这正是通过 GD 库来绘制图片的步骤. 问题的原因找到了
看完 build() 方法会看到 return $this, 于是可以通过 $builder = $builder-&amp;gt;build() 来获取最新的实例, 接下来就可以使用 inline() 方法了
ps: 其实就算没有 return $this (不使用 $builder = $builder-&amp;gt;build() 而用 $builder-&amp;gt;build() ) 也可以正常返回 base64 图片, 因为图片内容在方法中传回给实例的属性了, 在 inline() 方法中会调到到这些属性</description></item><item><title>一道小题--获取本月有多少天</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%80%E9%81%93%E5%B0%8F%E9%A2%98--%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%88%E6%9C%89%E5%A4%9A%E5%B0%91%E5%A4%A9/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%80%E9%81%93%E5%B0%8F%E9%A2%98--%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%88%E6%9C%89%E5%A4%9A%E5%B0%91%E5%A4%A9/</guid><description>$today = &amp;#34;2018-8-8&amp;#34;; echo date(&amp;#39;t&amp;#39;,strtotime($today));// t 为本月天数, 28-31之间 // date() 函数可以直接得出, 避免了 复杂的判断 闰年,几月 等</description></item><item><title>go-自定义-struct-转-json</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E8%87%AA%E5%AE%9A%E4%B9%89-struct-%E8%BD%AC-json/</link><pubDate>Thu, 14 Apr 2022 16:13:08 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E8%87%AA%E5%AE%9A%E4%B9%89-struct-%E8%BD%AC-json/</guid><description>需求: 从 api 获取到 json, 本地 unmarshal 为 struct 后, 以另外的 json tag marhsal 为 json 字符串 type Student struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` } strIn := `{ &amp;#34;stu_name&amp;#34;: &amp;#34;Jim Green&amp;#34;, &amp;#34;age&amp;#34;: 14 }` // to json strOut := `{ &amp;#34;name&amp;#34;: &amp;#34;Jim Green&amp;#34;, &amp;#34;age&amp;#34;: 14 }` 使用到的方法 UmarshalJOSN / MarshalJSON
方法一: 通过中间 struct 变量的匿名嵌套 struct embedding (注意防止无限循环使用 alias) package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type Student struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` } func (s *Student) UnmarshalJSON(data []byte) error { type Alias Student aux := &amp;amp;struct { *Alias StuName string `json:&amp;#34;stu_name&amp;#34;` }{ Alias: (*Alias)(s), } if err := json.</description></item><item><title>go-判断-https-ssl-证书是否过期</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E5%88%A4%E6%96%AD-https-ssl-%E8%AF%81%E4%B9%A6%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F/</link><pubDate>Fri, 25 Mar 2022 13:03:46 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E5%88%A4%E6%96%AD-https-ssl-%E8%AF%81%E4%B9%A6%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F/</guid><description>package main import ( &amp;#34;crypto/tls&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { conn, err := tls.Dial(&amp;#34;tcp&amp;#34;, &amp;#34;blog.umesh.wtf:443&amp;#34;, nil) if err != nil { panic(&amp;#34;Server doesn&amp;#39;t support SSL certificate err: &amp;#34; + err.Error()) } err = conn.VerifyHostname(&amp;#34;blog.umesh.wtf&amp;#34;) if err != nil { panic(&amp;#34;Hostname doesn&amp;#39;t match with certificate: &amp;#34; + err.Error()) } expiry := conn.ConnectionState().PeerCertificates[0].NotAfter fmt.Printf(&amp;#34;Issuer: %s\nExpiry: %v\n&amp;#34;, conn.ConnectionState().PeerCertificates[0].Issuer, expiry.Format(time.RFC850)) } 参考自 freecodecamp</description></item><item><title>php-进程线程</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</link><pubDate>Thu, 24 Feb 2022 13:25:15 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</guid><description>进程与线程的概念:
进程是 一个时间段: CPU 上下文切换之间的程序运行时 线程是进程之中的多个程序段的运行时, 线程共享进程的地址空间 (知乎: 线程和进程的区别是什么？)[https://www.zhihu.com/question/25532384]
php-fpm 是进程, 每个请求是单线程的 多个请求是并发(多线程)的</description></item><item><title>Duck-Type-鸭子类型</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/duck-type-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</link><pubDate>Wed, 23 Feb 2022 09:05:22 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/duck-type-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</guid><description>Duck Typing is a [type system] used in dynamic languages. For example, Python, Perl, Ruby, PHP, Javascript, etc. where the type or the class of an object is less important than the method it defines. Using Duck Typing, we do not check types at all. Instead, we check for the presence of a given method or attribute.
reference: geeksforgeeks
按上述来说, 鸭子类型是动态语言的特性, 在动态语言中, 类型并不重要, 重要的是类型(实例)的方法</description></item><item><title>删除文件夹中的node_modules子文件夹</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84node_modules%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</link><pubDate>Sat, 18 Sep 2021 10:12:01 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84node_modules%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</guid><description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;io/fs&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path&amp;#34; &amp;#34;path/filepath&amp;#34; ) func main() { if len(os.Args) == 1 { panic(&amp;#34;Enter a file name&amp;#34;) } src := os.Args[1] var pathList []string err := filepath.Walk(src, func(path string, info fs.FileInfo, err error) error { if err != nil { return err } if info.IsDir() &amp;amp;&amp;amp; info.Name() == &amp;#34;node_modules&amp;#34; { return filepath.SkipDir } if info.IsDir() { return nil } path = filepath.ToSlash(path) pathList = append(pathList, path) return nil }) if err !</description></item><item><title>centos-部署-go-web</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/centos-%E9%83%A8%E7%BD%B2-go-web/</link><pubDate>Fri, 17 Sep 2021 09:27:47 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/centos-%E9%83%A8%E7%BD%B2-go-web/</guid><description>编译后的文件上传至服务器, 有两个事情要做, 一是把 web 应用做成守护进程启动, 二是端口开放
使用纯净 centos7 环境(justhost.ru vps, 非阿里云环境)
1. 防火墙开放端口 1.1 查看防火墙状态
firewall-cmd --state # running 1.2 如果没有开启, 启动防火墙
systemctl start firewalld.service 1.3 开放 8080 端口
firewall-cmd --zone=public --add-port=8080/tcp --permanent # 开放多个端口 firewall-cmd --add-port=8081-8100/tcp --permanent 1.4 重启防火墙
systemctl restart firewall.service 1.5 重载配置
firewall-cmd --realod 1.6 查看端口开启情况
netstat -nltp # 或者使用 firewall-cmd 查看 # 查看所有 firewall-cmd --list-all # 查看指定 firewall-cmd --query-port=8080/tcp 1.7 移除端口
firewall-cmd --remove-port=8080/tcp --permanent 2. supervisord 守护进程 2.</description></item><item><title>不使用-struct-定义-json-字符串</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%8D%E4%BD%BF%E7%94%A8-struct-%E5%AE%9A%E4%B9%89-json-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Wed, 01 Sep 2021 09:07:16 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%8D%E4%BD%BF%E7%94%A8-struct-%E5%AE%9A%E4%B9%89-json-%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>// 方法一: 生写 string jsonStr := ` &amp;#34;name&amp;#34;: &amp;#34;Jack&amp;#34;, &amp;#34;age&amp;#34;: 25 ` // 方法二: map[string]interface{} jsonMap := map[string]interface{}{ &amp;#34;name&amp;#34;: &amp;#34;Jack&amp;#34;, &amp;#34;age&amp;#34;: 66, } jsonByte, _ = json.Marshal(jsonMap) jsonStr = string(jsonByte) 另外 jsonStr 转 io.Reader r := strings.NewReader(jsonStr)</description></item><item><title>go-结构体实例化</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%8C%96/</link><pubDate>Fri, 16 Jul 2021 10:21:06 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%8C%96/</guid><description>type Block struct { length int height int } // 方式一 var a Block a.length = 1 a.height = 2 // 方式二 b := Block{1, 2} // 方式三 c := &amp;amp;Block{1, 2} // 方式四 d := new(Block) d.length = 1 d.height = 2 fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) 方式一和二 相同, 结果都是 值对象 方式三和四 相同, 结果都是指针
值和指针的不同点在于, 如果需要对 结构体的实例进行修改时, 值需要加上 &amp;amp;, 而 指针不需要
如果一个 struct 内容很多, 占用内存大, 应该使用 指针而不是值来进行函数间的传递.
参考 segmentfault cnblog</description></item><item><title>flutter-gradle-问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/flutter-gradle-%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 24 Mar 2021 17:09:49 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/flutter-gradle-%E9%97%AE%E9%A2%98/</guid><description>更改 google() jcenter 无效后
gradle 下载地址 https://services.gradle.org/distributions/
参考: 快速解决 GRADLE 项目下载 gradle-*-all.zip 慢的问题</description></item><item><title>goland-import-包报红</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/goland-import-%E5%8C%85%E6%8A%A5%E7%BA%A2/</link><pubDate>Fri, 19 Feb 2021 09:52:51 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/goland-import-%E5%8C%85%E6%8A%A5%E7%BA%A2/</guid><description>在使用 go mod 后(go 1.11 开始支持, go 1.14 全面推荐), 无需在 GOPATH 的 src 下存在项目目录, 可以随意存放.
go 包依赖管理 gopath &amp;gt; go vender &amp;gt; go module, 参考 # 一文搞懂 Go Modules 前世今生及入门使用
GOPATH 则只存放第三方包, 若不设置, 默认为 /[user]/go 目录
goland 配置 GOROOT, GOPATH 及 Go Modules
结果会在 External Libraries 中多出一个 Go Modules</description></item><item><title>php-生成文件流,-不生成本地文件</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E6%B5%81-%E4%B8%8D%E7%94%9F%E6%88%90%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 09 Feb 2021 09:36:18 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E6%B5%81-%E4%B8%8D%E7%94%9F%E6%88%90%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/</guid><description>$string = &amp;#34;I tried, honestly! 中文&amp;#34;; $stream = fopen(&amp;#39;data://text/plain,&amp;#39; . $string,&amp;#39;r&amp;#39;); //file_put_contents(&amp;#39;./a.txt&amp;#39;, $stream); //echo stream_get_contents($stream); echo $stream; $string = &amp;#39;Some bad-ass string&amp;#39;; $stream = fopen(&amp;#39;php://memory&amp;#39;,&amp;#39;r+&amp;#39;); fwrite($stream, $string); rewind($stream); echo stream_get_contents($stream); 参考自: Creating streams from strings in PHP</description></item><item><title>类的-static-及-self</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E7%B1%BB%E7%9A%84-static-%E5%8F%8A-self/</link><pubDate>Mon, 21 Dec 2020 10:26:59 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E7%B1%BB%E7%9A%84-static-%E5%8F%8A-self/</guid><description>使用 self:: 或者 CLASS 对当前类的静态引用，指向 定义当前方法所在的类.
使用 static 对当前类的静态引用，指向 使用当前方法所在的类.
参见php.net 后期静态绑定</description></item><item><title>csrf-跨站请求伪造</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</link><pubDate>Fri, 20 Nov 2020 16:01:43 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</guid><description>CSRF（Cross-site request forgery）跨站请求伪造, 定义: 攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。 利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 一个典型的CSRF攻击有着如下的流程:
受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。 a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com以受害者的名义执行了act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 前后端分离时, 不使用 cookie, 则不会有 csrf 危险</description></item><item><title>php-的-session-文件</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%9A%84-session-%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 12 Oct 2020 15:34:47 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%9A%84-session-%E6%96%87%E4%BB%B6/</guid><description>由于 http 无状态性, 一般 MVC 可以使用session 用于存储用户信息.
&amp;lt;?php session_start(); // 开启 session, 将会生成一个 session_id, 通过 http 响应头返回给浏览器, 浏览器存储到本地的 cookie 中, 下次 http 请示会自动携带给服务端; // 同时会在服务端生成一个文件 如 sess_2rh6hq44kjbtagri2r88dj16b1 (后面一串为 session_id), 当前会话(通过 id保持) 的数据, 会保存在该文件中, 如 session(&amp;#39;name&amp;#39;, &amp;#39;test&amp;#39;) session_unset(); // 注销当前会话下的 session 变量, 但不会删除当前 sess_xxxx... 文件, 而是清空文件里的内容(key: value)</description></item><item><title>laravel-composer-dump-autoload-失败</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-composer-dump-autoload-%E5%A4%B1%E8%B4%A5/</link><pubDate>Fri, 28 Aug 2020 14:05:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-composer-dump-autoload-%E5%A4%B1%E8%B4%A5/</guid><description>报 class xxx not found
// 1. 执行 php artisan config:clear // 2. 再不行就执行 php artisan clear-compiled // 3. 再不行就把 vendor/composer/ 文件夹里 autoload_ 开头的文件删除</description></item><item><title>composer-version-constraint</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/composer-version-constraint/</link><pubDate>Fri, 15 May 2020 09:26:13 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/composer-version-constraint/</guid><description>Tilde ~2.1, means 2.1.0 &amp;lt;= version &amp;lt; 3.0.0 ~2.1.1, means 2.1.1 &amp;lt;= version &amp;lt; 2.2.0 Caret // - ^2.1, means 2.1.0 &amp;lt;= version &amp;lt; 3.0.0
^2.1.1, means 2.1.0 &amp;lt;= version &amp;lt; 3.0.0 Wildcard 2.1.*, means 2.1.0 &amp;lt;= version &amp;lt; 2.2.0 reference: composer</description></item><item><title>查询字段是否含有中文</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E4%B8%AD%E6%96%87/</link><pubDate>Sun, 16 Feb 2020 21:20:04 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E4%B8%AD%E6%96%87/</guid><description>SELECT col FROM table WHERE length(col)!=char_length(col) 通过查询长度和字符个数是否相等, 相等则不包含中文, 不相等则包含中文
原文见cnblog</description></item><item><title>laravel-多对多关联时,-会出现-pivot-字段,-如何删除</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%97%B6-%E4%BC%9A%E5%87%BA%E7%8E%B0-pivot-%E5%AD%97%E6%AE%B5-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4/</link><pubDate>Mon, 13 Jan 2020 10:28:39 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%97%B6-%E4%BC%9A%E5%87%BA%E7%8E%B0-pivot-%E5%AD%97%E6%AE%B5-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4/</guid><description>$user-&amp;gt;roles-&amp;gt;makeHidden(&amp;#39;pivot&amp;#39;); // 或者在 model 中 protect $hidden = [&amp;#39;pivot&amp;#39;];</description></item><item><title>laravel-wechat-公众号更换url时报-token-验证失败</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-wechat-%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9B%B4%E6%8D%A2url%E6%97%B6%E6%8A%A5-token-%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5/</link><pubDate>Mon, 30 Dec 2019 16:58:43 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-wechat-%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9B%B4%E6%8D%A2url%E6%97%B6%E6%8A%A5-token-%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5/</guid><description> VerifyCsrfToken 中间件, 排除 微信相关的 路由, 见文档 是否开启了 debugbar, 关闭之, 见github</description></item><item><title>golang-删除-slice-中的部分元素</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/golang-%E5%88%A0%E9%99%A4-slice-%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 08 Nov 2019 16:08:40 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/golang-%E5%88%A0%E9%99%A4-slice-%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0/</guid><description>golang 对 slice 的操作全在 [:] 中 和 append
// 删除切片的第三个元素 sslice := []int{0,1,2,3,4} sslice = append(sslice[:2], sslice[3:]...) Notice
sslice[A:B], 包涵 A, 不包括 B; 若 A = B,包涵 A append 第一个参数为 切片, 第二(三,四)个参数为 元素, 若为 切片, 可以使用 &amp;hellip; 分解 (析构) 为元素</description></item><item><title>golang-给-struct-赋值-nil</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/golang-%E7%BB%99-struct-%E8%B5%8B%E5%80%BC-nil/</link><pubDate>Fri, 08 Nov 2019 15:28:22 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/golang-%E7%BB%99-struct-%E8%B5%8B%E5%80%BC-nil/</guid><description>struct ListNode { Val int Next *ListNode } var li *ListNode = nil 原文见csdn</description></item><item><title>go-环境变量设置-proxy</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE-proxy/</link><pubDate>Wed, 06 Nov 2019 17:08:15 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE-proxy/</guid><description>Go version &amp;gt;= 1.13 当你的GO的版本大于1.13的时候 当你安装的GO的语言版本大于1.13的时候，那么就不用这么麻烦了，直接使用go env -w命令就行了
go env -w GOPROXY=https://goproxy.io,direct go env -w GOPRIVATE=*.corp.example.com go env -w GO111MODULE=on 转自掘金</description></item><item><title>c语言中的-sleep()-函数在-windows-和-linux-下的不同表示</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-sleep-%E5%87%BD%E6%95%B0%E5%9C%A8-windows-%E5%92%8C-linux-%E4%B8%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%A4%BA/</link><pubDate>Tue, 15 Oct 2019 15:39:21 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-sleep-%E5%87%BD%E6%95%B0%E5%9C%A8-windows-%E5%92%8C-linux-%E4%B8%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%A4%BA/</guid><description>在 windows 中, Sleep()
// test.c #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;windows.h&amp;gt; int main(){ Sleep(3000); printf(&amp;#39;hello C&amp;#39;); return 0; } 在 linux 中, sleep()
// test.c #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main(){ sleep(3000); printf(&amp;#39;hello C&amp;#39;); return 0; }</description></item><item><title>查看路由(接口数)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%9F%A5%E7%9C%8B%E8%B7%AF%E7%94%B1%E6%8E%A5%E5%8F%A3%E6%95%B0/</link><pubDate>Tue, 24 Sep 2019 22:40:31 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%9F%A5%E7%9C%8B%E8%B7%AF%E7%94%B1%E6%8E%A5%E5%8F%A3%E6%95%B0/</guid><description>// web php artisan route:list | wc -l | awk &amp;#39;{print $1 - 4}&amp;#39; // api $ php artisan api:route | wc -l | awk &amp;#39;{print $1 - 4}&amp;#39; 原文见 learnku</description></item><item><title>laravel-队列</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E9%98%9F%E5%88%97/</link><pubDate>Tue, 24 Sep 2019 22:40:09 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E9%98%9F%E5%88%97/</guid><description>windows 中使用 horizon, 原文见 github, learnku composer require laravel/horizon --ignore-platform-reqs php artisan vendor:publish --provider=&amp;#34;Laravel\Horizon\HorizonServiceProvider&amp;#34; 在 .env 中将 QUEUE_CONNECTION 改为 reids 后需要在命令行运行 php artisan queue:listen 或 php artisan queue:work 才会开启队列中的任务
因为错误原因一直重复执行某一个队列, 重启 redis 依然如此, 那么需要清空 redis 中的数据 redis-cli #进入脚手架 flushall #清空redis的数据 learnku overtrue 给队列新建 redis 连接</description></item><item><title>array_filter-过滤数组中值为空的元素</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/array_filter-%E8%BF%87%E6%BB%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%80%BC%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%85%83%E7%B4%A0/</link><pubDate>Thu, 29 Aug 2019 11:21:16 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/array_filter-%E8%BF%87%E6%BB%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%80%BC%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%85%83%E7%B4%A0/</guid><description>array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) : array 通过回调函数返回 true 返回过滤数组中的单元, 组成新数组并最终返回
如果, callable 为空, 则默认过滤数组中等值为 false 的单元(如 null, &amp;lsquo;&amp;rsquo;, &amp;rsquo; &amp;lsquo;, 0) 等</description></item><item><title>laravel-关联模型使用-with-调数据时指定字段出错</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8-with-%E8%B0%83%E6%95%B0%E6%8D%AE%E6%97%B6%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%87%BA%E9%94%99/</link><pubDate>Tue, 20 Aug 2019 16:18:28 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8-with-%E8%B0%83%E6%95%B0%E6%8D%AE%E6%97%B6%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%87%BA%E9%94%99/</guid><description>laravel 关联模型使用 with 调数据时指定字段必须包括 外键的字段 参考: laravel5.1 eloquent with 通过闭包筛选特定 field 得不到结果的问题</description></item><item><title>laradock-数据库连接</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laradock-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</link><pubDate>Fri, 02 Aug 2019 10:20:49 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laradock-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</guid><description> adminer 容器 up 后, 在 127.0.0.1:8080 使用 [ &amp;lsquo;服务器&amp;rsquo; =&amp;gt; &amp;lsquo;mysql&amp;rsquo; ], root + root 默认账户可以登录; 在 navicat 中, 则使用 127.0.0.1 + root + root 即可登录 新的 mysql 数据库可以新建一个测试用户
CREATE USER &amp;#39;test&amp;#39;@&amp;#39;%&amp;#39; IDENTIFIED BY &amp;#39;test&amp;#39;; GRANT ALL ON *.* TO &amp;#39;test&amp;#39;@&amp;#39;%&amp;#39;</description></item><item><title>vue-@input-事件</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/vue-input-%E4%BA%8B%E4%BB%B6/</link><pubDate>Fri, 12 Jul 2019 15:49:26 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/vue-input-%E4%BA%8B%E4%BB%B6/</guid><description>input 事件 结合了 keyup事件 和 change事件, 会在 keyup 时判断值是否发生变化, 变化了则触发该事件
// html &amp;lt;input v-model=&amp;#34;keyword&amp;#34; type=&amp;#34;text&amp;#34; id=&amp;#34;search&amp;#34; @input=&amp;#34;onSearch&amp;#34; autofocus class=&amp;#34;input_search&amp;#34; placeholder=&amp;#34;问题或选项关键词&amp;#34;&amp;gt; // js onSearch() { ... keyup事件 也可以使用一个旧值在 keyup 的时候来比较值是否变化, 如果没有变化就直接return, 否则给旧值赋上新值, 再进行接下去的业务逻辑
// html &amp;lt;input v-model=&amp;#34;keyword&amp;#34; type=&amp;#34;text&amp;#34; id=&amp;#34;search&amp;#34; @keyup=&amp;#34;onSearch&amp;#34; autofocus class=&amp;#34;input_search&amp;#34; placeholder=&amp;#34;问题或选项关键词&amp;#34;&amp;gt; // js onSearch() { if(this.keyword === this.keyword_old){ return } this.keyword_old = this.keyword ...</description></item><item><title>laravel-policy-返回值类型只能是-boolean(true-或-false)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-policy-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%83%BD%E6%98%AF-booleantrue-%E6%88%96-false/</link><pubDate>Mon, 24 Jun 2019 17:05:06 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-policy-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%83%BD%E6%98%AF-booleantrue-%E6%88%96-false/</guid><description>不能为 int string array 等</description></item><item><title>php-二维数据排序</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E4%BA%8C%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 13 Jun 2019 09:17:11 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E4%BA%8C%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/</guid><description>&amp;lt;?php $arr = [ [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 3, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 5, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 2, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 4, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 1, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], ]; //usort($arr,function ($a,$b){ // return $a[&amp;#39;id&amp;#39;] &amp;gt; $b[&amp;#39;id&amp;#39;] ? 1 : -1; //}); array_multisort($arr); var_dump($arr);</description></item><item><title>tp5-布署-linux-注意事项</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-%E5%B8%83%E7%BD%B2-linux-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Wed, 12 Jun 2019 08:55:28 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-%E5%B8%83%E7%BD%B2-linux-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description> 给 public 目录权限 项目根目录下新建空的 runtime 目录, 并设置 777 权限</description></item><item><title>laravel--Request-类-通过后的-$request-包含无需验证的-字段</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel--request-%E7%B1%BB-%E9%80%9A%E8%BF%87%E5%90%8E%E7%9A%84-request-%E5%8C%85%E5%90%AB%E6%97%A0%E9%9C%80%E9%AA%8C%E8%AF%81%E7%9A%84-%E5%AD%97%E6%AE%B5/</link><pubDate>Sun, 26 May 2019 09:24:39 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel--request-%E7%B1%BB-%E9%80%9A%E8%BF%87%E5%90%8E%E7%9A%84-request-%E5%8C%85%E5%90%AB%E6%97%A0%E9%9C%80%E9%AA%8C%E8%AF%81%E7%9A%84-%E5%AD%97%E6%AE%B5/</guid><description>// Request 类: $rule = [ &amp;#39;email&amp;#39; =&amp;gt; &amp;#39;required|email&amp;#39;, &amp;#39;password&amp;#39; =&amp;gt; &amp;#39;required|alpha_dash|between:6,20&amp;#39; ]; // form { name: &amp;#39;abc&amp;#39;, email: &amp;#39;abc@qq.com&amp;#39;, password: &amp;#39;123456&amp;#39;, } // Request $request [ &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;abc&amp;#39;, &amp;#39;email&amp;#39; =&amp;gt; &amp;#39;abc@qq.com&amp;#39;, &amp;#39;password&amp;#39; =&amp;gt; &amp;#39;123456&amp;#39;, ] $request 里面会包含 name 这个没有 ( 无需 ) 验证的字段</description></item><item><title>php-json_encode-报错-Malformed-UTF-8-characters</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-json_encode-%E6%8A%A5%E9%94%99-malformed-utf-8-characters/</link><pubDate>Wed, 22 May 2019 15:10:19 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-json_encode-%E6%8A%A5%E9%94%99-malformed-utf-8-characters/</guid><description>当使用了 substr() 进行字符串切割后, 再进行 json_encode() 时, 报错
改使用 mb_substr() 即可
原因: substr 按字节数进行截取产生了特殊字符, 而 mb_substr 按字符数截取, 则没有问题</description></item><item><title>php-substr-截取中文出乱码</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-substr-%E6%88%AA%E5%8F%96%E4%B8%AD%E6%96%87%E5%87%BA%E4%B9%B1%E7%A0%81/</link><pubDate>Tue, 21 May 2019 17:02:59 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-substr-%E6%88%AA%E5%8F%96%E4%B8%AD%E6%96%87%E5%87%BA%E4%B9%B1%E7%A0%81/</guid><description>使用 mb_substr 解决即可,
mb_substr 按字符来截取 而 substr 按字节来截取</description></item><item><title>php文件上传临时目录</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95/</link><pubDate>Thu, 16 May 2019 14:57:47 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95/</guid><description>问题: 在上传表单中, 用户没有继续进行保存下去, 那么图片(或文件)会一直保存下去 ?
在 php.ini 中, php官方文档 (语言参考-&amp;gt;特点-&amp;gt;文件上传处理-&amp;gt;post方法上传):
文件被上传后，默认地会被储存到服务端的默认临时目录中，除非 php.ini 中的 upload_tmp_dir 设置为其它的路径。服务端的默认临时目录可以通过更改 PHP 运行环境的环境变量 TMPDIR 来重新设置，但是在 PHP 脚本内部通过运行 putenv() 函数来设置是不起作用的。该环境变量也可以用来确认其它的操作也是在上传的文件上进行的。
了解Redis过期策略及实现原理. 我们在使用redis时，一般会设置一个过期时间，当然也有不设置过期时间的，也就是永久不过期。
当我们设置了过期时间，redis是如何判断是否过期，以及根据什么策略来进行删除的。
redis设置过期时间： expire key time(以秒为单位)–这是最常用的方式 setex(String key, int seconds, String value)–字符串独有的方式
除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间
如果没有设置时间，那缓存就是永不过期
如果设置了过期时间，之后又想让缓存永不过期，使用persist key
三种过期策略 定时删除 含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除 优点：保证内存被尽快释放 缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key. 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重 懒汉式式删除 含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null。 优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了） 缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存） 定期删除 含义：每隔一段时间执行一次删除过期key操作 优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点 缺点：在内存友好方面，不如”定时删除”（会造成一定的内存占用，但是没有懒汉式那么占用内存） 在CPU时间友好方面，不如”懒汉式删除”（会定期的去进行比较和删除操作，cpu方面不如懒汉式，但是比定时好） 难点：合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了），每次执行时间太长，或者执行频率太高对cpu都是一种压力。每次进行定期删除操作执行之后，需要记录遍历循环到了哪个标志位，以便下一次定期时间来时，从上次位置开始进行循环遍历 说明：memcached只是用了惰性删除，而redis同时使用了惰性删除与定期删除，这也是二者的一个不同点（可以看做是redis优于memcached的一点）；对于懒汉式删除而言，并不是只有获取key的时候才会检查key是否过期，在某些设置key的方法上也会检查（eg.setnx key2 value2：该方法类似于memcached的add方法，如果设置的key2已经存在，那么该方法返回false，什么都不做；如果设置的key2不存在，那么该方法设置缓存key2-value2。假设调用此方法的时候，发现redis中已经存在了key2，但是该key2已经过期了，如果此时不执行删除操作的话，setnx方法将会直接返回false，也就是说此时并没有重新设置key2-value2成功，所以对于一定要在setnx执行之前，对key2进行过期检查）。 Redis采用的过期策略 懒汉式删除+定期删除 懒汉式删除流程：
在进行get或setnx等操作时，先检查key是否过期； 若过期，删除key，然后执行相应操作； 若没过期，直接执行相应操作； 定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key） 遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16） 检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体是下边的描述） 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。 对于定期删除，在程序中有一个全局变量current_db来记录下一个将要遍历的库，假设有16个库，我们这一次定期删除遍历了10个，那此时的current_db就是11，下一次定期删除就从第11个库开始遍历，假设current_db等于15了，那么之后遍历就再从0号库开始（此时current_db==0）</description></item><item><title>laravel-使用-composer-dump-autoload</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E4%BD%BF%E7%94%A8-composer-dump-autoload/</link><pubDate>Tue, 14 May 2019 10:35:39 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E4%BD%BF%E7%94%A8-composer-dump-autoload/</guid><description>给 User.php 模型文件复制一次为 bak.User.php 后, 执行了一次 vendor:publish , 给出了warning:
再之后 , 依赖注入 User 模型提示 User 找不到 解决办法: 执行 composer dump-autoload</description></item><item><title>git-修改本地及远程分支的名称</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/git-%E4%BF%AE%E6%94%B9%E6%9C%AC%E5%9C%B0%E5%8F%8A%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E5%90%8D%E7%A7%B0/</link><pubDate>Tue, 07 May 2019 14:50:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/git-%E4%BF%AE%E6%94%B9%E6%9C%AC%E5%9C%B0%E5%8F%8A%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E5%90%8D%E7%A7%B0/</guid><description>原文地址
git branch -m old_branch new_branch # Rename branch locally git push origin :old_branch # Delete the old branch git push --set-upstream origin new_branch # Push the new branch, set local branch to track the new remote // 第三步不在推送时关联远程分支, 可改为如下 git branch --set-upstream-to origin/master git branch -u origin/new_branch</description></item><item><title>git-撤消commit,-并恢复改动</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/git-%E6%92%A4%E6%B6%88commit-%E5%B9%B6%E6%81%A2%E5%A4%8D%E6%94%B9%E5%8A%A8/</link><pubDate>Sun, 05 May 2019 09:58:38 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/git-%E6%92%A4%E6%B6%88commit-%E5%B9%B6%E6%81%A2%E5%A4%8D%E6%94%B9%E5%8A%A8/</guid><description>git reset HEAD^1</description></item><item><title>laravel-生命周期--路由实例</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F--%E8%B7%AF%E7%94%B1%E5%AE%9E%E4%BE%8B/</link><pubDate>Fri, 03 May 2019 19:31:42 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F--%E8%B7%AF%E7%94%B1%E5%AE%9E%E4%BE%8B/</guid><description>{{host}}/api/topics/:topic/replies
如上路由(需要登录, 在中间件中使用了 api.auth)
实测发现
如果 :topic 不存在, 则报 404, 说明首先走的路由中隐性绑定的数据模型; 填入正确的 topic id 后, 报错 401, authenticate failed, 说明第二步走的中间件; 填入正确的 bearer token, 报错 422, Unprocessable Entity, 提示 xx 参数不能为空或格式不正确, 说明这里才开始进行 request 表单请求类验证</description></item><item><title>laravel-路由参数与控制器进行隐性绑定</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%9A%90%E6%80%A7%E7%BB%91%E5%AE%9A/</link><pubDate>Mon, 29 Apr 2019 14:53:29 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%9A%90%E6%80%A7%E7%BB%91%E5%AE%9A/</guid><description>// 路由文件 Route(&amp;#39;topics/{topic}&amp;#39;, &amp;#39;TopicsController@show&amp;#39;); // 控制器 public function show(Topics $topic) { // todo } 其中路由中的 {topic} 是与 控制器中的 $topic 进行绑定的, 如果前面写成 id, 后面则用 $id, 也能正确进行模型绑定
// 路由文件 Route(&amp;#39;topics/{id}&amp;#39;, &amp;#39;TopicsController@show&amp;#39;); // 控制器 public function show(Topics $id) { // todo } 参考自 learnku</description></item><item><title>laravel-request-中-使用路由参数</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-request-%E4%B8%AD-%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0/</link><pubDate>Sat, 20 Apr 2019 23:31:30 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-request-%E4%B8%AD-%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0/</guid><description>在 Controller 中使用请求参数直接使用 $request-&amp;gt;input(&amp;rsquo;name&amp;rsquo;) 或 $request-&amp;gt;name;
在 Controller 中使用路由参数直接使用 参数注入 或 $request-&amp;gt;name;
在 Request 中, 使用请求参数使用 $this-&amp;gt;input(&amp;rsquo;name&amp;rsquo;) 或 $this-&amp;gt;name
在 Request 中, 使用请求参数使用 $this-&amp;gt;name, (不能使用参数注入)
在使用动态属性时，Laravel 首先会在请求载体中查找参数的值。如果该值不存在，Lavarel 将在路由参数中搜索。</description></item><item><title>access_token-和-refresh_token</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/access_token-%E5%92%8C-refresh_token/</link><pubDate>Thu, 04 Apr 2019 11:37:44 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/access_token-%E5%92%8C-refresh_token/</guid><description>设置 access_token 为 1 天有效期, refresh_token 为 7 天有效期, 如果 access_token 未过期, 则直接通过登录判断 (不更新 access_token 或 refresh_token ) 当 access_token 过期, 则检测 refresh_token , refresh_token 未过期时, 更新并返回 access_token 和 refresh_token 当 access_token 过期, refresh_token 也过期, 则返回未登录 ps: 由于 refresh_token 的有效期大于 access_token 的有效期 (而二者是同时更新的), 所以不存在 access_token 未过期, 而 refresh_token 过期的情况</description></item><item><title>lnmp-环境中-使用-system-函数被报安全因素无法启用</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/lnmp-%E7%8E%AF%E5%A2%83%E4%B8%AD-%E4%BD%BF%E7%94%A8-system-%E5%87%BD%E6%95%B0%E8%A2%AB%E6%8A%A5%E5%AE%89%E5%85%A8%E5%9B%A0%E7%B4%A0%E6%97%A0%E6%B3%95%E5%90%AF%E7%94%A8/</link><pubDate>Tue, 02 Apr 2019 09:43:30 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/lnmp-%E7%8E%AF%E5%A2%83%E4%B8%AD-%E4%BD%BF%E7%94%A8-system-%E5%87%BD%E6%95%B0%E8%A2%AB%E6%8A%A5%E5%AE%89%E5%85%A8%E5%9B%A0%E7%B4%A0%E6%97%A0%E6%B3%95%E5%90%AF%E7%94%A8/</guid><description>原因: 要在 php 中使用 mysqldump 进行数据库备份 在本地 wamp 环境中使用没有问题 在线上 lnmp 环境下报错 system 函数无法使用
解决办法:
查看线上 php.ini 文件是否开启 safe_mode (安全模式); 2.1.1 如果开启了 安全模式, 则查看 disable_function 是否禁用了 system 函数 2.1.2 如果 disable_function 是禁用了 system 函数, 那么取消禁用, 并在 safe_mode_exec_dir 中添加一个包含要执行命令的目录
2.2.1 如果未开户安全模式, 直接查看 disable_function 是否禁用了 system 函数, 取消掉即可</description></item><item><title>让-tp5-api-返回-json-格式的异常</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E8%AE%A9-tp5-api-%E8%BF%94%E5%9B%9E-json-%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%BC%82%E5%B8%B8/</link><pubDate>Tue, 26 Mar 2019 21:31:04 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E8%AE%A9-tp5-api-%E8%BF%94%E5%9B%9E-json-%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%BC%82%E5%B8%B8/</guid><description>见: https://blog.csdn.net/qq_38287952/article/details/80247000</description></item><item><title>如何让-Laravel-API-永远返回-JSON-格式响应？</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%A6%82%E4%BD%95%E8%AE%A9-laravel-api-%E6%B0%B8%E8%BF%9C%E8%BF%94%E5%9B%9E-json-%E6%A0%BC%E5%BC%8F%E5%93%8D%E5%BA%94/</link><pubDate>Tue, 26 Mar 2019 21:29:07 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%A6%82%E4%BD%95%E8%AE%A9-laravel-api-%E6%B0%B8%E8%BF%9C%E8%BF%94%E5%9B%9E-json-%E6%A0%BC%E5%BC%8F%E5%93%8D%E5%BA%94/</guid><description>见: https://www.jianshu.com/p/c0b7365a21e5
当你在编写完全为 API 服务的 Laravel 应用时，你希望所有响应都是 JSON 格式的，而不是例如说授权错误会重定向到 /home 或 /login，最终重定向会变成 InvalidArgumentException: Route [login] is not defined. 的视图。 下面这个简单的方案，可以让你的 Laravel 应用优先响应为 JSON 格式。 第一步、编写 BaseRequest 首先我们需要构建一个 BaseRequest 来重写 Illuminate\Http\Request ，修改为默认优先使用 JSON 响应： app/Http/Requests/BaseRequest.php</description></item><item><title>php-json_decode-函数</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-json_decode-%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 26 Mar 2019 17:13:41 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-json_decode-%E5%87%BD%E6%95%B0/</guid><description>json_decode 把 json 字符串转成 object 或 array
$str = &amp;#39;{&amp;#34;id&amp;#34;:1, &amp;#34;name&amp;#34;:&amp;#34;hello&amp;#34;}&amp;#39;; $obj = json_decode($str); // 转成对象 $arr = json_decode($str, true);// 转成数组 // 要求 // json 字符串中的键值必须用 双引号(&amp;#34;&amp;#34;) 包裹起来, 单引号或者不用引号都不能正确解析, 结果会是 null</description></item><item><title>fastadmin----跨域问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin----%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 21 Feb 2019 08:49:23 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin----%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</guid><description>原文见: https://forum.fastadmin.net/thread/7485
在入口文件 index.php 中添加如下代码
header(&amp;#34;Access-Control-Allow-Origin: *&amp;#34;); header(&amp;#34;Access-Control-Allow-Methods: GET, POST&amp;#34;); header(&amp;#34;Access-Control-Allow-Headers: Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With&amp;#34;);</description></item><item><title>fastadmin----nginx-配置----解决除首页外的404问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin----nginx-%E9%85%8D%E7%BD%AE----%E8%A7%A3%E5%86%B3%E9%99%A4%E9%A6%96%E9%A1%B5%E5%A4%96%E7%9A%84404%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 21 Feb 2019 08:46:08 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin----nginx-%E9%85%8D%E7%BD%AE----%E8%A7%A3%E5%86%B3%E9%99%A4%E9%A6%96%E9%A1%B5%E5%A4%96%E7%9A%84404%E9%97%AE%E9%A2%98/</guid><description>原文见: https://forum.fastadmin.net/thread/8320
在 nginx 配置文件中加入如下代码
server { ``` listen 80; server_name www.abc.com abc.com; index index.php index.html index.htm default.php default.htm default.html; root /www/wwwroot/abc/public; location / { index index.html index.htm index.php; #autoindex on; if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则 #error_page 404/404.html; #SSL-END #ERROR-PAGE-START 错误页配置，可以注释、删除或修改 error_page 404 /404.html; error_page 502 /502.html; #ERROR-PAGE-END #PHP-INFO-START PHP引用配置，可以注释或修改 include enable-php-72.conf; #PHP-INFO-END #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效 #include /www/server/panel/vhost/rewrite/www.xfguoye.com.conf; #REWRITE-END #禁止访问的文件或目录 location ~ ^/(\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md) { return 404; } #一键申请SSL证书验证目录相关设置 location ~ \.</description></item><item><title>tp5-数据集(对象)转成数组(再转json)输出</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%88%90%E6%95%B0%E7%BB%84%E5%86%8D%E8%BD%ACjson%E8%BE%93%E5%87%BA/</link><pubDate>Tue, 05 Feb 2019 14:12:44 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%88%90%E6%95%B0%E7%BB%84%E5%86%8D%E8%BD%ACjson%E8%BE%93%E5%87%BA/</guid><description>原文见: https://www.jianshu.com/p/a69164fd1f50?utm_campaign
先在数据库配置文件中 // 数据集返回类型 &amp;#39;resultset_type&amp;#39; =&amp;gt; &amp;#39;collection&amp;#39;, 在使用时, 使用 toArray() 方法 // 查询数据库 $news = NewsModel::order(&amp;#39;createtime desc&amp;#39;)-&amp;gt;limit($num)-&amp;gt;page($page)-&amp;gt;select()-&amp;gt;toArray(); /* array (size=2) 0 =&amp;gt; array (size=8) &amp;#39;id&amp;#39; =&amp;gt; int 2 &amp;#39;title&amp;#39; =&amp;gt; string &amp;#39;2&amp;#39; (length=1) &amp;#39;title_image&amp;#39; =&amp;gt; string &amp;#39;2&amp;#39; (length=1) &amp;#39;label_name&amp;#39; =&amp;gt; string &amp;#39;2&amp;#39; (length=1) &amp;#39;content&amp;#39; =&amp;gt; string &amp;#39;&amp;lt;p&amp;gt;2&amp;lt;/p&amp;gt;&amp;#39; (length=8) &amp;#39;link_url&amp;#39; =&amp;gt; string &amp;#39;2&amp;#39; (length=1) &amp;#39;createtime&amp;#39; =&amp;gt; int 1549338746 &amp;#39;updatetime&amp;#39; =&amp;gt; int 1549338746 1 =&amp;gt; array (size=8) &amp;#39;id&amp;#39; =&amp;gt; int 1 &amp;#39;title&amp;#39; =&amp;gt; string &amp;#39;dd&amp;#39; (length=2) &amp;#39;title_image&amp;#39; =&amp;gt; string &amp;#39;&amp;#39; (length=0) &amp;#39;label_name&amp;#39; =&amp;gt; string &amp;#39;&amp;#39; (length=0) &amp;#39;content&amp;#39; =&amp;gt; string &amp;#39;dd&amp;#39; (length=2) &amp;#39;link_url&amp;#39; =&amp;gt; string &amp;#39;&amp;#39; (length=0) &amp;#39;createtime&amp;#39; =&amp;gt; int 11 &amp;#39;updatetime&amp;#39; =&amp;gt; int 11 */</description></item><item><title>php-trait-的优先级</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-trait-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</link><pubDate>Tue, 22 Jan 2019 21:04:44 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-trait-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</guid><description>&amp;lt;?php trait Demo1{ public function test(){ return __METHOD__; } } trait Demo2{ public function test(){ return __METHOD__; } } class Demo0{ public function test(){ return __METHOD__; } } class Demo extends Demo0{ use Demo1,Demo2{ Demo1::test insteadof Demo2; // tait1中的test方法优先于trait2中的test方法(如果不这么设置,同名的方法会导致报错) Demo2::test as demo2test; // trait2 的test方法别名为 trait2test } } $obj = new demo(); $obj-&amp;gt;test();// Demo1::test $obj-&amp;gt;demo2test();// Demo2::test trait ,当前类,父类优先级: 当前类方法 &amp;gt; trait 的方法 &amp;gt; 父类的方法 如果当前类引用了两个 trait, 并且这两个 trait 中有同名方法,则会报错, 可以使用 insteadof 指定使用哪个trait的方法, 此外还可以用 as 来设置别名, 从而供当前类使用</description></item><item><title>正则表达式-cheat-sheet-from-github</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-cheat-sheet-from-github/</link><pubDate>Mon, 21 Jan 2019 14:59:34 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-cheat-sheet-from-github/</guid><description>转载自: https://github.com/niklongstone/regular-expression-cheat-sheet.git
Regular Expression Cheat Sheet - PCRE Anchor Description Example Valid match Invalid ^ start of string or line ^foam foam bath foam \A start of string in any match mode \Afoam foam bath foam $ end of string or line finish$ finish finnish \Z end of string, or char before last new line in any match mode finish\Z finish finnish \z end of string, in any match mode.</description></item><item><title>openssl-加密函数</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/openssl-%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0/</link><pubDate>Thu, 17 Jan 2019 13:29:20 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/openssl-%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0/</guid><description>后台使用密码保存时, 使用 md5, 不可解密;
如今想给一个登录 token 加密, 原始做法是用 md5+一定数量的字符串, 并且在缓存(或数据库)中保存这个键值对;
如果不想在后台保存 token 信息, 可以把 token信息(包括过期时间,用户账号等) 使用 open_ssl 加密, 然后要在后台要验证的时候, 再解密出来
例如
&amp;lt;?php $key = &amp;#39;key123456789&amp;#39;;//加密字符串的密码, 类似于md5加盐 $method = &amp;#39;AES-128-CBC&amp;#39;;// 加密方法 $arr = [&amp;#39;user_id&amp;#39;=&amp;gt;1, &amp;#39;expire_time&amp;#39;=&amp;gt;60*60]; // 用户id为1, 有效期为1h $str = json_encode($arr); $secret_str = openssl_encrypt($str,$method,$key);// 加密字符串 $secret_str = urlencode($secret_str);// 加密字符串 var_dump($secret_str);// jRX%2BtqOyhHVOzHX7cFI0usMUs7qKH4uEaOqKkdBQ2A08C1FmRRGXWFBfCleJPu3i $origin_str = urldecode($secret_str); $origin_str = openssl_decrypt($origin_str,$method,$key);// 解密字符串 var_dump($origin_str);// {&amp;#34;user_id&amp;#34;:1,&amp;#34;expire_time&amp;#34;:3600} var_dump(json_decode($origin_str));// [&amp;#34;user_id&amp;#34;=&amp;gt;1,&amp;#34;expire_time&amp;#34;=&amp;gt;3600] // 加密 openssl_encrypt ( string $data , string $method , string $key [, int $options = 0 [, string $iv = &amp;#34;&amp;#34; [, string &amp;amp;$tag = NULL [, string $aad = &amp;#34;&amp;#34; [, int $tag_length = 16 ]]]]] ) : string // 解密 openssl_decrypt ( string $data , string $method , string $key [, int $options = 0 [, string $iv = &amp;#34;&amp;#34; [, string $tag = &amp;#34;&amp;#34; [, string $aad = &amp;#34;&amp;#34; ]]]] ) : string // data // The encrypted message to be decrypted.</description></item><item><title>nginx-反向代理</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link><pubDate>Wed, 16 Jan 2019 13:43:33 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid><description>正向代理是 客户端向指定的服务器发起请求, 客户是隐藏的;
反向代理, 则是隐藏了多个服务器, 由代理服务器决定向(集群服务器组)哪个服务器发起请求
参考自: https://blog.csdn.net/tsummerb/article/details/79248015</description></item><item><title>onethink-后台编辑器选择问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/onethink-%E5%90%8E%E5%8F%B0%E7%BC%96%E8%BE%91%E5%99%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 11 Jan 2019 14:04:25 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/onethink-%E5%90%8E%E5%8F%B0%E7%BC%96%E8%BE%91%E5%99%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98/</guid><description>
public function adminArticleEdit($data){ $res= $this-&amp;gt;getConfig(); // var_dump($res); $res[&amp;#39;editor_type&amp;#39;]=2; $this-&amp;gt;assign(&amp;#39;addons_data&amp;#39;, $data); // $this-&amp;gt;assign(&amp;#39;addons_config&amp;#39;, $this-&amp;gt;getConfig()); $this-&amp;gt;assign(&amp;#39;addons_config&amp;#39;, $res); $this-&amp;gt;display(&amp;#39;content&amp;#39;); } }</description></item><item><title>phpqrcode-生成的图片转为-base64-格式输出</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/phpqrcode-%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E4%B8%BA-base64-%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA/</link><pubDate>Thu, 10 Jan 2019 22:20:42 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/phpqrcode-%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E4%B8%BA-base64-%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA/</guid><description>原文见: https://www.pusonglin.cn/work/1619.html
项目中需要用到phpqrcode生成二维码，但是通过QRcode::png()生成的是显示输出当前的照片流，这样就不适用于列表显示多个二维码的需求了。网上也有相关的一些解决方案:通过把照片流缓存，然后进行base64编码。
找到生成图片用到了QRimage类的png方法，去除里面的：Header(“Content-type: image/png”);即可。
class QRimage { //---------------------------------------------------------------------- public static function png($frame, $filename = false, $pixelPerPoint = 4, $outerFrame = 4,$saveandprint=FALSE) { $image = self::image($frame, $pixelPerPoint, $outerFrame); if ($filename === false) { // Header(&amp;#34;Content-type: image/png&amp;#34;); ImagePng($image); } else { if($saveandprint===TRUE){ ImagePng($image, $filename); header(&amp;#34;Content-type: image/png&amp;#34;); ImagePng($image); }else{ ImagePng($image, $filename); } } ImageDestroy($image); } 如此，不再让输出端整个页面变为图片类型，解决方案并不完美，但是能达到我的目的即可。 附调用端代码：
&amp;lt;?php global $_W,$_GPC; function getqrcode($url){ require_once MODULE_ROOT.&amp;#39;/lib/phpqrcode_web.php&amp;#39;; $value = $url; //二维码内容 $errorCorrectionLevel = &amp;#39;L&amp;#39;; //容错级别 $matrixPointSize = 5; //生成图片大小 //生成二维码图片 ob_start(); QRcode::png($value,false,$errorCorrectionLevel, $matrixPointSize, 2); $imgstr = base64_encode(ob_get_contents()); ob_end_clean(); return $imgstr; } //调用查看结果 include $this-&amp;gt;template(&amp;#39;web/test&amp;#39;); ?</description></item><item><title>正则表达式-----必须含有大写字母和数字</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-----%E5%BF%85%E9%A1%BB%E5%90%AB%E6%9C%89%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97/</link><pubDate>Thu, 10 Jan 2019 13:36:05 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-----%E5%BF%85%E9%A1%BB%E5%90%AB%E6%9C%89%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97/</guid><description>原文见:https://blog.csdn.net/u011974797/article/details/71479456
要求：由数字和字母组成，并且要同时含有数字和字母，且长度要在8-16位之间。
^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8,16}$
分开来注释一下： ^ 匹配一行的开头位置 (?![0-9]+$) 预测该位置后面不全是数字 (?![a-zA-Z]+$) 预测该位置后面不全是字母 [0-9A-Za-z] {8,16} 由8-16位数字或这字母组成 $ 匹配行结尾位置
注：(?!xxxx) 是正则表达式的负向零宽断言一种形式，标识预该位置后不是xxxx字符。
附：
要求：可以包含数字、字母、下划线，并且要同时含有数字和字母，且长度要在8-16位之间。 ^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z_]{8,16}$</description></item><item><title>HTML+CSS底部footer两种固定方式</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/html+css%E5%BA%95%E9%83%A8footer%E4%B8%A4%E7%A7%8D%E5%9B%BA%E5%AE%9A%E6%96%B9%E5%BC%8F/</link><pubDate>Fri, 28 Dec 2018 15:21:22 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/html+css%E5%BA%95%E9%83%A8footer%E4%B8%A4%E7%A7%8D%E5%9B%BA%E5%AE%9A%E6%96%B9%E5%BC%8F/</guid><description>原文见: https://blog.csdn.net/xianglikai1/article/details/78411615
网页常见的底部栏（footer）目前有两种：
一、永久固定，不管页面的内容有多高，footer一直位于浏览器最底部，适合做移动端底部菜单，这个比较好实现;
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=utf-8&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;style&amp;gt; body { padding-bottom: 50px; } .footer { position: fixed; left: 0px; bottom: 0px; width: 100%; height: 50px; background-color: #eee; z-index: 9999; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 内容，可以大量复制看效果&amp;lt;br /&amp;gt; &amp;lt;div class=&amp;#34;footer&amp;#34;&amp;gt;固定在底部&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 二、相对固定，当页面内容高度不沾满浏览器高度，footer显示在浏览器底部，且不会出现滚动条，如果页面内容高度超出浏览器高度，footer则相对与内容的最底部，并且自动出现滚动条；
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=utf-8&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; * { margin: 0px; padding: 0px; } html, body { height: 100%; } .</description></item><item><title>fastadmin-隐藏后台登陆地址</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin-%E9%9A%90%E8%97%8F%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E5%9C%B0%E5%9D%80/</link><pubDate>Sun, 23 Dec 2018 20:38:09 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin-%E9%9A%90%E8%97%8F%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E5%9C%B0%E5%9D%80/</guid><description>我们都知道后台/admin是我们最常用的登录入口，方便的同时也留下了隐患，如果你刚好使用了admin/123456这种账号密码的方式，会导致我们的后台完全暴露在外。 因此我们建议修改后台的登录入口，达到隐藏后台登录入口的效果。 原文见:https://forum.fastadmin.net/thread/7640
操作步骤 1、首页修改application/config.php中deny_module_list的值，其中默认已经有common，我们添加admin，改成['common', 'admin'] 2、然后修改项目public目录下的admin.php，将其改名为admin_d75KABNWt.php，我们可以将admin.php其中的admin改成任意随机的字符串，越长越好。
登录后台 通过以上的修改后，我们不能再通过[www.yoursite.com/admin](http://www.yoursite.com/admin)的形式登录后台了，此时我们可以采用[www.yoursite.com/admin_d75KABNWt.php](http://www.yoursite.com/admin_d75KABNWt.php)，其中admin_d75KABNWt.php就是我们任意修改的名称。 请保护好你后台的登录入口，千万别到处去粘贴，如果有泄漏后台入口，请再次尝试修改即可。
安全建议 通过上面的隐藏后台入口地址，我们已经加好了第一道门，以下是FastAdmin给大家的安全建议，为我们后台添加更多的安全防护。 1、定期修改后台管理的登录入口和超级管理员密码，越复杂越好。 2、开启后台登录验证码，开启方式：修改application/config.php底部中login_captcha，将它的值改为true 3、修改后台超级管理员用户名，默认是admin，建议修改，修改方式直接在权限管理-&amp;gt;管理员管理中修改 4、移除冗余的管理员，早期FastAdmin中默认添加了几个管理员用于权限划分，建议删除。</description></item><item><title>fastadmin-忘记后台账号密码</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin-%E5%BF%98%E8%AE%B0%E5%90%8E%E5%8F%B0%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/</link><pubDate>Sun, 23 Dec 2018 20:36:44 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin-%E5%BF%98%E8%AE%B0%E5%90%8E%E5%8F%B0%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/</guid><description>https://forum.fastadmin.net/thread/43
数据库修改两个字段 密码：c13f62012fd6a8fdf06b3452a94430e5 密码盐：rpR6Bv 登录密码是123456</description></item><item><title>simditor-的使用</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/simditor-%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 22 Dec 2018 14:12:44 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/simditor-%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&amp;lt;textarea id=&amp;#34;editor&amp;#34;&amp;gt;{$introduction}&amp;lt;/textarea&amp;gt; &amp;lt;script&amp;gt; var editor = new Simditor({ textarea: $(&amp;#39;#editor&amp;#39;), toolbarHidden: true }); &amp;lt;/script&amp;gt; 如果一个页面使用多个 simditor 编辑器, 那么每个编辑器的 id 要设置为不同
&amp;lt;volist name=&amp;#34;industries&amp;#34; id=&amp;#34;vo&amp;#34;&amp;gt; &amp;lt;if condition=&amp;#34;$i eq 2&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;zi&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;fs14 f-c9c&amp;#34;&amp;gt; &amp;lt;textarea id=&amp;#34;editor{$i}&amp;#34;&amp;gt;{$vo.content}&amp;lt;/textarea&amp;gt; &amp;lt;script&amp;gt; var editor{$i} = new Simditor({ textarea: $(&amp;#39;#editor{$i}&amp;#39;), toolbarHidden: true }); &amp;lt;/script&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;else/&amp;gt; &amp;lt;div class=&amp;#34;zi f-dn&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;fs14 f-c9c&amp;#34;&amp;gt; &amp;lt;textarea id=&amp;#34;editor{$i}&amp;#34;&amp;gt;{$vo.content}&amp;lt;/textarea&amp;gt; &amp;lt;script&amp;gt; var editor{$i} = new Simditor({ textarea: $(&amp;#39;#editor{$i}&amp;#39;), toolbarHidden: true }); &amp;lt;/script&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/if&amp;gt; &amp;lt;/volist&amp;gt;</description></item><item><title>http-状态码</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/http-%E7%8A%B6%E6%80%81%E7%A0%81/</link><pubDate>Sun, 09 Dec 2018 19:44:46 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/http-%E7%8A%B6%E6%80%81%E7%A0%81/</guid><description>HTTP 提供了丰富的状态码供我们使用，正确的使用状态码可以让响应数据更具可读性。
200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 操作进行响应。也可以被用在不创建新资源的 POST 操作上 201 Created - 对创建新资源的 POST 操作进行响应。应该带着指向新资源地址的 Location 头 202 Accepted - 服务器接受了请求，但是还未处理，响应中应该包含相应的指示信息，告诉客户端该去哪里查询关于本次请求的信息 204 No Content - 对不会返回响应体的成功请求进行响应（比如 DELETE 请求） 304 Not Modified - HTTP缓存header生效的时候用 400 Bad Request - 请求异常，比如请求中的body无法解析 401 Unauthorized - 没有进行认证或者认证非法 403 Forbidden - 服务器已经理解请求，但是拒绝执行它 404 Not Found - 请求一个不存在的资源 405 Method Not Allowed - 所请求的 HTTP 方法不允许当前认证用户访问 410 Gone - 表示当前请求的资源不再可用。当调用老版本 API 的时候很有用 415 Unsupported Media Type - 如果请求中的内容类型是错误的 422 Unprocessable Entity - 用来表示校验错误 429 Too Many Requests - 由于请求频次达到上限而被拒绝访问 [转载], [原文见] https://laravel-china.</description></item><item><title>laravel-中用「hash_equals」防止时序攻击</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E4%B8%AD%E7%94%A8hash_equals%E9%98%B2%E6%AD%A2%E6%97%B6%E5%BA%8F%E6%94%BB%E5%87%BB/</link><pubDate>Sun, 09 Dec 2018 19:42:25 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E4%B8%AD%E7%94%A8hash_equals%E9%98%B2%E6%AD%A2%E6%97%B6%E5%BA%8F%E6%94%BB%E5%87%BB/</guid><description>比对验证码是否与缓存中一致时，使用了 hash_equals 方法。
hash_equals($verifyData[&amp;#39;code&amp;#39;], $request-&amp;gt;verification_code) hash_equals 是可防止时序攻击的字符串比较，那么什么是时序攻击呢？比如这段代码我们使用
$verifyData[&amp;#39;code&amp;#39;] == $request-&amp;gt;verification_code 进行比较，那么两个字符串是从第一位开始逐一进行比较的，发现不同就立即返回 false，那么通过计算返回的速度就知道了大概是哪一位开始不同的，这样就实现了电影中经常出现的按位破解密码的场景。而使用 hash_equals 比较两个字符串，无论字符串是否相等，函数的时间消耗是恒定的，这样可以有效的防止时序攻击。
[原文见laravel-china.org:] (https://laravel-china.org/courses/laravel-advance-training/5.5/building-a-user-registration-interface/929)</description></item><item><title>fastadmin-使用-simditor-不显示</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin-%E4%BD%BF%E7%94%A8-simditor-%E4%B8%8D%E6%98%BE%E7%A4%BA/</link><pubDate>Wed, 05 Dec 2018 16:22:12 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/fastadmin-%E4%BD%BF%E7%94%A8-simditor-%E4%B8%8D%E6%98%BE%E7%A4%BA/</guid><description>需要把 『根目录 addons』 中的 assets 中的文件夹复制一份到 『根目录 public』中的 assets/addons/simditor 中</description></item><item><title>帝国cms更改后台页面</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcms%E6%9B%B4%E6%94%B9%E5%90%8E%E5%8F%B0%E9%A1%B5%E9%9D%A2/</link><pubDate>Wed, 05 Dec 2018 16:01:54 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcms%E6%9B%B4%E6%94%B9%E5%90%8E%E5%8F%B0%E9%A1%B5%E9%9D%A2/</guid><description>1.登陆页面, e/admin/index.php 2.后台首页, e/admin/main.php 3.后台首页, e/admin/adminstyle/1/AdminMain.php</description></item><item><title>onethink-一张表(模型)只能有一个字段设置为编辑器的解决办法</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/onethink-%E4%B8%80%E5%BC%A0%E8%A1%A8%E6%A8%A1%E5%9E%8B%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link><pubDate>Wed, 05 Dec 2018 15:03:11 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/onethink-%E4%B8%80%E5%BC%A0%E8%A1%A8%E6%A8%A1%E5%9E%8B%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid><description>原文见:http://www.topthink.com/topic/8867.html
在后台建立两个编辑器字段,发现提交表单时,两个字段的值不能进行更新,原因是在生成代码时,编辑器的对象名相同导致的,在这里可以通过修改 Addons\EditorForAdmin\content.html 文件来实现多个编辑器字段值的更新</description></item><item><title>onethink-模型(表)增加-时间自动完成字段</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/onethink-%E6%A8%A1%E5%9E%8B%E8%A1%A8%E5%A2%9E%E5%8A%A0-%E6%97%B6%E9%97%B4%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E5%AD%97%E6%AE%B5/</link><pubDate>Wed, 05 Dec 2018 15:02:10 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/onethink-%E6%A8%A1%E5%9E%8B%E8%A1%A8%E5%A2%9E%E5%8A%A0-%E6%97%B6%E9%97%B4%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E5%AD%97%E6%AE%B5/</guid><description>需要到对应表的模型 xxxModel.class.php 进行添加字段为 auto 完成</description></item><item><title>帝国cms搜索模板制作</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcms%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF%E5%88%B6%E4%BD%9C/</link><pubDate>Tue, 04 Dec 2018 10:22:59 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcms%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF%E5%88%B6%E4%BD%9C/</guid><description>&amp;lt;form name=&amp;#34;searchform&amp;#34; method=&amp;#34;post&amp;#34; action=&amp;#34;/e/search/index.php&amp;#34;&amp;gt; &amp;lt;!--按表搜索--&amp;gt; &amp;lt;input type=&amp;#34;hidden&amp;#34; name=&amp;#34;tbname&amp;#34; value=&amp;#34;activity&amp;#34;&amp;gt; &amp;lt;!--所用搜索模板--&amp;gt; &amp;lt;input type=&amp;#34;hidden&amp;#34; name=&amp;#34;tempid&amp;#34; value=&amp;#34;3&amp;#34;&amp;gt; &amp;lt;!--搜索字段变量--&amp;gt; &amp;lt;input type=&amp;#34;hidden&amp;#34; name=&amp;#34;show&amp;#34; value=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;!--搜索范围不限制--&amp;gt; &amp;lt;input type=&amp;#34;hidden&amp;#34; name=&amp;#34;member&amp;#34; value=&amp;#34;0&amp;#34;&amp;gt; &amp;lt;!--查询逻辑, 默认模糊查询--&amp;gt; &amp;lt;input type=&amp;#34;hidden&amp;#34; name=&amp;#34;hh&amp;#34; value=&amp;#34;LK&amp;#34;&amp;gt; &amp;lt;!--按关键词搜索--&amp;gt; &amp;lt;input name=&amp;#34;keyboard&amp;#34; type=&amp;#34;text&amp;#34; placeholder=&amp;#34;输入活动关键词&amp;#34;&amp;gt; &amp;lt;button type=&amp;#34;submit&amp;#34; name=&amp;#34;submit&amp;#34;&amp;gt;搜 索&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 模板的所属系统模型要与『要搜索的表』一致 对应的系统模型中对应搜索字段要选中</description></item><item><title>帝国cms-如何调用-栏目(表)-的全部字段信息</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcms-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8-%E6%A0%8F%E7%9B%AE%E8%A1%A8-%E7%9A%84%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF/</link><pubDate>Wed, 07 Nov 2018 18:08:21 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%B8%9D%E5%9B%BDcms-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8-%E6%A0%8F%E7%9B%AE%E8%A1%A8-%E7%9A%84%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF/</guid><description>使用 e:loop 标签调用时, 会发现有些字段不能够读取出来, 可能是因为该字段没有加入到 列表模板或内容模板中
(亲测可用)
也可能是该字段不在 主表 中(此项没有测试, 未知是否正确)</description></item><item><title>onethink-后台验证码输错一次后,再次输入(正确)依然提示错误</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/onethink-%E5%90%8E%E5%8F%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E9%94%99%E4%B8%80%E6%AC%A1%E5%90%8E%E5%86%8D%E6%AC%A1%E8%BE%93%E5%85%A5%E6%AD%A3%E7%A1%AE%E4%BE%9D%E7%84%B6%E6%8F%90%E7%A4%BA%E9%94%99%E8%AF%AF/</link><pubDate>Wed, 31 Oct 2018 13:58:03 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/onethink-%E5%90%8E%E5%8F%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E9%94%99%E4%B8%80%E6%AC%A1%E5%90%8E%E5%86%8D%E6%AC%A1%E8%BE%93%E5%85%A5%E6%AD%A3%E7%A1%AE%E4%BE%9D%E7%84%B6%E6%8F%90%E7%A4%BA%E9%94%99%E8%AF%AF/</guid><description>if(!check_verify($verify)){ // $this-&amp;gt;error(&amp;#39;验证码输入错误！&amp;#39;); // $this-&amp;gt;error(&amp;#39;验证码输入错误！&amp;#39;,U(&amp;#39;/Admin/Public/login&amp;#39;),2);// 自己改 $this-&amp;gt;error(&amp;#39;验证码输入错误！&amp;#39;,&amp;#39;Admin/Public/login&amp;#39;,2); } success方法的默认跳转地址是 $_SERVER[&amp;ldquo;HTTP_REFERER&amp;rdquo;] ， error方法的默认跳转地址是 javascript:history.back(-1); 。
原因: 因为默认的 $this-&amp;gt;error , 是通过 javascript:history.back(-1) 跳转的, 这样就依然显示之前生成的验证码, 而后台已经生成新的验证码, 所以会出现报错;
解决办法: 把 error 方法的路径填写, 那么会相当于重新打开登陆页面, 也就可以正常登陆</description></item><item><title>restful--patch-和-put-请求的区别</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/restful--patch-%E5%92%8C-put-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 01 Sep 2018 20:34:49 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/restful--patch-%E5%92%8C-put-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>看到 laravel 使用 Route::resource 生成 restful 架构的路由, 里面的更新用的是 patch 请求, 而有的地方说是用 put, 就查了一下, 这篇说得很明白, 就复制过来了
put 更新全部资源 patch 方法用来更新局部资源 假设我们有一个UserInfo，里面有userId， userName， userGender等10个字段。可你的编辑功能因为需求，在某个特别的页面里只能修改userName，这时候的更新怎么做？
人们通常(为徒省事)把一个包含了修改后userName的完整userInfo对象传给后端，做完整更新。但仔细想想，这种做法感觉有点二，而且真心浪费带宽(纯技术上讲，你不关心带宽那是你土豪)。
于是patch诞生，只传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段。
而put虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象，理论上说，如果你用了put，但却没有提供完整的UserInfo，那么缺了的那些字段应该被清空
原文见 https://blog.csdn.net/mysevenyear/article/details/80674080</description></item><item><title>laravel-学习笔记1_20180829</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01_20180829/</link><pubDate>Wed, 29 Aug 2018 10:12:07 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01_20180829/</guid><description>######1. 在修改完 Homestead.yaml 文件后, 需要在本机加载并重启 vagrant, 执行如下
&amp;gt; vagrant provision &amp;amp;&amp;amp; vagrant reload ######2. git 初始化(保存到本地), 设置远程仓库及使用默认远程仓库
$ git init $ git add -A $ git commit -m &amp;#34;Initial commit&amp;#34; $ git remote add origin git@github.com:&amp;lt;user_name&amp;gt;/&amp;lt;repositoy_name&amp;gt;.git $ git push -u origin master 其中, origin 作为默认的远程仓库服务器名 ( 也可以改成别的 ), &amp;lt;user_name&amp;gt; 指的是 git 中的用户名, &amp;lt;repositoy_name&amp;gt; 指的是 git 中的仓库名
git push -u origin master 意为将本地 master 分支推送到 origin 远程仓库; 其中 -u 指的是将 origin 和 master 连接起来, 以后即可以直接使用 git push 则代表推送 master 到 origin</description></item><item><title>mysqldump备份时出错</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/mysqldump%E5%A4%87%E4%BB%BD%E6%97%B6%E5%87%BA%E9%94%99/</link><pubDate>Sun, 15 Jul 2018 23:06:58 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/mysqldump%E5%A4%87%E4%BB%BD%E6%97%B6%E5%87%BA%E9%94%99/</guid><description>mysqldump备份时出现 couldn&amp;rsquo;t find table 或 Got error: 1049: Unknown database 错误
原因可能是, 在命令行的末尾不能加入 分号
原因是通过DOS运行mysql命令的情况下，相当于没有进入mysql环境，不能再在命令行结束处加分号；，直接属于命令行即可！
原文见: https://blog.csdn.net/song19890528/article/details/9620981</description></item><item><title>用-uploadifive-插件上传文件时的问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E7%94%A8-uploadifive-%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 20 May 2018 17:33:38 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E7%94%A8-uploadifive-%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>官方文档错误 fileType 的值是 &amp;lsquo;fileType&amp;rsquo;: &amp;lsquo;image&amp;rsquo; 而不能是 &amp;lsquo;fileType&amp;rsquo;: &amp;lsquo;image/*&amp;rsquo;
后台用tp5框架时, 返回值如果是数组,则要通过json_encode [ 或者tp5 的 json ]函数进行转码, 而不能直接 return[即使配置文件中设置了 &amp;lsquo;default_return_type&amp;rsquo; =&amp;gt; &amp;lsquo;json&amp;rsquo;,] 否则会出现错误</description></item><item><title>phpstorm-快捷生成函数的注释</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/phpstorm-%E5%BF%AB%E6%8D%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E9%87%8A/</link><pubDate>Wed, 16 May 2018 23:46:17 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/phpstorm-%E5%BF%AB%E6%8D%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E9%87%8A/</guid><description>在函数上一行键入 /**
/** * @param $a * @param $b * @return mixed */ function abc($a, $b) { $c = $a + $b; return $c; } 然后 enter 回车即可</description></item><item><title>php-正则匹配中文</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87/</link><pubDate>Tue, 15 May 2018 18:56:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87/</guid><description>php正则匹配汉字!
$reg = &amp;lsquo;/^[\x{4e00}-\x{9fa5}]+$/u&amp;rsquo;;
而不是 $reg = &amp;lsquo;/^[\u4e00-\u9fa5]+$/u&amp;rsquo;;</description></item><item><title>thinkphp5-模板渲染-在控制器中不能-少了return</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93-%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E4%B8%8D%E8%83%BD-%E5%B0%91%E4%BA%86return/</link><pubDate>Thu, 26 Apr 2018 18:00:40 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93-%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E4%B8%8D%E8%83%BD-%E5%B0%91%E4%BA%86return/</guid><description>namespace module\controller; use think\Controller; class index extends Controller { public function index{ return this-&amp;gt;view-&amp;gt;fetch(&amp;#39;index&amp;#39;); } }</description></item><item><title>ThinkPHP5-对无限分类数组进行分页显示</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-%E5%AF%B9%E6%97%A0%E9%99%90%E5%88%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E6%98%BE%E7%A4%BA/</link><pubDate>Thu, 26 Apr 2018 11:16:20 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-%E5%AF%B9%E6%97%A0%E9%99%90%E5%88%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E6%98%BE%E7%A4%BA/</guid><description>use think\Controller; use think\paginator\driver\Bootstrap; class Category extends Controller { public function index2() { // 1.获取要分页的数组 $cate = CategoryModel::getCate();// 无限分类后的数组 $data = $cate; // 1.1 设置当前分页(从url get方式获取), 每页显示记录行数 $curPage = input(&amp;#39;page&amp;#39;) ? input(&amp;#39;page&amp;#39;) : 1; $listRow = 3; // 1.2 得到当前分页所要显示的数组(array_chunk 或 array_slice 函数) $showData = array_chunk($data, $listRow, true); $showData = $showData[$curPage - 1]; // $showData = array_slice($data, ($curPage - 1) * $listRow, $listRow, true); // 1.3 调用Bootstrap类方法生成分页对象 $p = Bootstrap::make($showData, $listRow, $curPage, count($data), false, [ &amp;#39;var_page&amp;#39; =&amp;gt; &amp;#39;page&amp;#39;, &amp;#39;path&amp;#39; =&amp;gt; url(&amp;#39;category/index2&amp;#39;), // 这里根据需要修改url &amp;#39;query&amp;#39; =&amp;gt; [], &amp;#39;fragment&amp;#39; =&amp;gt; &amp;#39;&amp;#39;, ]); $p-&amp;gt;appends($_GET); // 添加URL参数 // 2.</description></item><item><title>在弹窗通过layer插件打开的情况下，采用jQuery-Ajax提交表单后，弹窗无法关闭</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%9C%A8%E5%BC%B9%E7%AA%97%E9%80%9A%E8%BF%87layer%E6%8F%92%E4%BB%B6%E6%89%93%E5%BC%80%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%87%E7%94%A8jquery-ajax%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E5%90%8E%E5%BC%B9%E7%AA%97%E6%97%A0%E6%B3%95%E5%85%B3%E9%97%AD/</link><pubDate>Tue, 24 Apr 2018 20:08:57 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%9C%A8%E5%BC%B9%E7%AA%97%E9%80%9A%E8%BF%87layer%E6%8F%92%E4%BB%B6%E6%89%93%E5%BC%80%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%87%E7%94%A8jquery-ajax%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E5%90%8E%E5%BC%B9%E7%AA%97%E6%97%A0%E6%B3%95%E5%85%B3%E9%97%AD/</guid><description>原文地址:https://blog.csdn.net/cc_niu/article/details/77949829
自己代码:
&amp;lt;script&amp;gt; jQuery(&amp;#34;#updatebtn&amp;#34;).click(function () { jQuery.ajax({ type: &amp;#39;POST&amp;#39;, url: &amp;#34;&amp;lt;{:url(&amp;#39;admin/admin/update&amp;#39;)}&amp;gt;&amp;#34;, data: jQuery(&amp;#34;.layui-form&amp;#34;).serialize(), dataType: &amp;#39;json&amp;#39;, success: function (data) { if (data.status == 1) { // 成功返回 alert(data.message); // 刷新父级窗口,即可关闭当前窗口 window.parent.location.reload(); } else { // 失败返回 alert(data.message); window.location.href = &amp;#34;&amp;lt;{:url(&amp;#39;admin/edit&amp;#39;)}&amp;gt;&amp;#34;; } } }) }); &amp;lt;/script&amp;gt;</description></item><item><title>jQuery-AJAX-提交表单信息时,提交按钮不能为-submit</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/jquery-ajax-%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E4%BF%A1%E6%81%AF%E6%97%B6%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E4%B8%8D%E8%83%BD%E4%B8%BA-submit/</link><pubDate>Tue, 24 Apr 2018 19:17:50 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/jquery-ajax-%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E4%BF%A1%E6%81%AF%E6%97%B6%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E4%B8%8D%E8%83%BD%E4%B8%BA-submit/</guid><description>ajax代码:
&amp;lt;script&amp;gt; jQuery(&amp;#34;#btn&amp;#34;).click(function () { jQuery.ajax({ type: &amp;#39;POST&amp;#39;, url: &amp;#34;&amp;lt;{:url(&amp;#39;admin/admin/update&amp;#39;)}&amp;gt;&amp;#34;, data: jQuery(&amp;#34;form&amp;#34;).serialize(), dataType: &amp;#39;json&amp;#39;, success: function (data) { if (data.status == 1) { alert(data.message); // window.location.href = &amp;#34;&amp;lt;{:url(&amp;#39;admin/index&amp;#39;)}&amp;gt;&amp;#34;; } else { alert(data.message); // window.location.href = &amp;#34;&amp;lt;{:url(&amp;#39;admin/edit&amp;#39;)}&amp;gt;&amp;#34;; } } }) }); &amp;lt;/script&amp;gt; html文件可以是:
&amp;lt;input type=&amp;#34;button&amp;#34; id=&amp;#34;btn0&amp;#34; value=&amp;#34;保存&amp;#34;&amp;gt; &amp;lt;button type=&amp;#34;button&amp;#34; id=&amp;#34;btn1&amp;#34;&amp;gt;保存&amp;lt;/button&amp;gt; &amp;lt;a&amp;gt;保存&amp;lt;/a&amp;gt;</description></item><item><title>php路径</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 19 Mar 2018 18:14:04 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E8%B7%AF%E5%BE%84/</guid><description>/ 代表服务器根目录 ./ 代表当前同一级目录 ../ 代表上一级目录</description></item><item><title>PHP封装一个自己的my_parse_ini_file()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84my_parse_ini_file/</link><pubDate>Tue, 30 Jan 2018 22:30:33 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84my_parse_ini_file/</guid><description>PHP文件提取练习[parse_ini_file() ] ： 编写一个自己的 my_parse_ini_file() ，完成对 .ini 文件的读取 提示: explode 分割字符串 / fgets 读取一行数据 &amp;lt;?php function my_parse_ini_file($dir) { if (!file_exists($dir)) { echo &amp;#39;文件不存在, 无法访问&amp;#39;; return FALSE; } else { $fsize = filesize($dir); $fp = fopen($dir, &amp;#39;r&amp;#39;); $con_str = fread($fp, $fsize); // 把字符串中的空白字符&amp;#39; &amp;#39;替换为&amp;#39;&amp;#39;, 也就是删除空白字符 $con_str = str_replace(&amp;#39; &amp;#39;, &amp;#39;&amp;#39;, $con_str); // 按回车换行给字符串分割成数组 $arr_temp1 = explode(&amp;#34;\r\n&amp;#34;, $con_str); $arr_res = array(); foreach ($arr_temp1 as $value) { $arr_temp2 = explode(&amp;#39;=&amp;#39;, $value); $arr_res[$arr_temp2[0]] = $arr_temp2[1]; } return $arr_res; } } $file_full_path = &amp;#39;e:/config.</description></item><item><title>双引号和单引号----由sql语句中的字符串变量而来</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8D%95%E5%BC%95%E5%8F%B7----%E7%94%B1sql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E8%80%8C%E6%9D%A5/</link><pubDate>Fri, 12 Jan 2018 13:43:35 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8D%95%E5%BC%95%E5%8F%B7----%E7%94%B1sql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E8%80%8C%E6%9D%A5/</guid><description>在用php操作mysql 表的时候,遇到一个问题 表结构: CREATE TABLE news ( id int(10) unsigned NOT NULL AUTO_INCREMENT, title varchar(50) DEFAULT NULL, content text, add_time int(11) DEFAULT NULL, PRIMARY KEY (id) );
写了条sql语句
结果第一条可以正确显示,第二条却出错
原因在于title字段类型是字符串,所以其中的变量要用引号引起来 也就是 $sql2 = &amp;ldquo;SELECT * FROM news WHERE title=&amp;rsquo;$title&amp;rsquo;&amp;rdquo;;
由此举例php中单双引号的使用情况如下:</description></item><item><title>数据库事务四大特性</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 08 Jan 2018 12:34:33 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7/</guid><description>数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。
数据库事务的四大特性(简称ACID)是：
(1) 原子性(Atomicity) 事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。 例如银行取款事务分为2个步骤(1)存折减款(2)提取现金。不可能存折减款，却没有提取现金。2个步骤必须同时完成或者都不完成。
(2)一致性(Consistency) 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。 例如完整性约束a+b=10，一个事务改变了a，那么b也应随之改变。
(3)分离性(亦称独立性Isolation) 分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。
(4)持久性(Durability) 持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。
原文地址: http://blog.csdn.net/wolenski/article/details/7980521</description></item><item><title>mysql语句分类-DML-DDL-DCL</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB-dml-ddl-dcl/</link><pubDate>Sun, 07 Jan 2018 16:47:33 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB-dml-ddl-dcl/</guid><description>DML（data manipulation language）： 它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言
DDL（data definition language）： DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用
DCL（Data Control Language）： 是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</description></item><item><title>mysql-group-by-having-查询时别名</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql-group-by-having-%E6%9F%A5%E8%AF%A2%E6%97%B6%E5%88%AB%E5%90%8D/</link><pubDate>Fri, 05 Jan 2018 15:03:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql-group-by-having-%E6%9F%A5%E8%AF%A2%E6%97%B6%E5%88%AB%E5%90%8D/</guid><description>select deptname,count(*) as &amp;lsquo;专业个数&amp;rsquo; from class group by deptname having 专业个数&amp;gt;1;
having后面的别名不能用引号</description></item><item><title>mysql-数值类型指定宽度</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%AE%9A%E5%AE%BD%E5%BA%A6/</link><pubDate>Fri, 05 Jan 2018 11:28:53 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%AE%9A%E5%AE%BD%E5%BA%A6/</guid><description>mysql 数值类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。 但是这里的(4) 需要和 zerofill 一起用, 否则不会有效果.
当结合可选扩展属性ZEROFILL使用时， 默认补充的空格用零代替。例如，对于声明为INT(5) ZEROFILL的列，值4检索为00004。
如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。</description></item><item><title>mysql-复制表结构</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql-%E5%A4%8D%E5%88%B6%E8%A1%A8%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 04 Jan 2018 23:45:13 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql-%E5%A4%8D%E5%88%B6%E8%A1%A8%E7%BB%93%E6%9E%84/</guid><description>实例: mysql&amp;gt;create database db2018 charset=utf8 collate utf8_general_ci; mysql&amp;gt;create table tb1(id int,name varchar(20)) engine=myisam charset=utf8;
创建一个临时表tbtemp,结构与tb1一致 mysql&amp;gt;create table tbtemp like tb1;</description></item><item><title>MySQL查看当前数据库database【三种方法】</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93database%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Thu, 04 Jan 2018 23:28:49 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93database%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>在MySQL下查看当前使用的是哪个数据库，有三种方式
（1）用select database()语句
mysql&amp;gt; select database(); +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+ | database() | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+ | test | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+ 1 row in set (0.00 sec)
从查询结果中可以看出，当前用的是test数据库
（2）用show tables语句，查询出来的结果中，第一行为Tables_in_XXX，这里XXX就
是当前所用的数据库名称。
mysql&amp;gt; show tables; +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ | Tables_in_test | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ | push_test | | ship_order_detail | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ 2 rows in set (0.00 sec)
从查询结果中可以看出，当前用的是test数据库。
（3）用status语句，查询出来的结果中有一行是currrent database: XXX。这里XXX就 是当前所用的数据库名称。
mysql&amp;gt; status; mysql Ver 14.14 Distrib 5.1.60, for pc-linux-gnu (i686) using EditLine wrapper Connection id: 1484237 Current database: test Current user: root@localhost SSL: Not in use</description></item><item><title>mysql中-date_add(date,interval-type)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql%E4%B8%AD-date_adddateinterval-type/</link><pubDate>Mon, 06 Nov 2017 18:14:01 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/mysql%E4%B8%AD-date_adddateinterval-type/</guid><description>mysql中 date_add(date,interval type) 中, date类型不能为&amp;quot;时间戳&amp;quot;.</description></item><item><title>php-双引号调用函数</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E5%8F%8C%E5%BC%95%E5%8F%B7%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 03 Sep 2017 10:46:25 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E5%8F%8C%E5%BC%95%E5%8F%B7%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</guid><description/></item><item><title>php获取时间有误</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E6%9C%89%E8%AF%AF/</link><pubDate>Sun, 27 Aug 2017 00:06:40 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E6%9C%89%E8%AF%AF/</guid><description>我们用echo date(&amp;ldquo;Y-m-d H:i:s&amp;rdquo;);获取当前时间； 但有时我们会发现我们获取的时间其实比北京时间少8个小时（获取的是标准时间），这说明我们没有修改php配置文件里面的data属性。
如果我们想获取的是当前北京时间的话，我们必须将我们的php.ini配置文件修改一下：
[Date] ; Defines the default timezone used by the date functions date.timezone = &amp;lsquo;PRC&amp;rsquo;
这样即可，同理我们可以更改‘PRC’获取不同地区的当前时间。
ps：我这是wamp装的php，这里的php.ini不光在 wanmp/bin/php/php5.6.25/ 里的php.ini要改；wanmp/bin/apache/apache2.4.23/bin 里的php.ini 也要改</description></item></channel></rss>