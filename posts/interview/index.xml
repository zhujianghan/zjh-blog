<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interview | Posts on Fourleaf Blog</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/</link><description>Recent content in Interview | Posts on Fourleaf Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Sep 2022 17:25:46 +0800</lastBuildDate><atom:link href="https://zhujianghan.github.io/zjh-blog/posts/interview/index.xml" rel="self" type="application/rss+xml"/><item><title>Exercise_go_test_是否回文</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/exercise_go_test_palindrome/</link><pubDate>Fri, 09 Sep 2022 17:25:46 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/exercise_go_test_palindrome/</guid><description>编写一个回文检测函数，并为其编写单元测试和基准测试，根据测试的结果逐步对其进行优化。（回文：一个字符串正序和逆序一样，如“Madam,I’mAdam”、“油灯少灯油”等。） 来源:李文周blog
tip: 要考虑中文则使用 rune
// palindrome/palindrome.go package palindrome func IsPalindrome(s string) bool { // 转成 rune, 应对中文等特殊字符 r := []rune(s) l := len(r) for i := 0; i &amp;lt; l/2; i++ { if r[i] != r[l-1-i] { return false } } return true } // palindrome/palindrome_test.go package palindrome import ( &amp;#34;fmt&amp;#34; &amp;#34;testing&amp;#34; ) func TestIsPalindrome(t *testing.T) { type test struct { text string want bool } arr := []test{ {&amp;#34;&amp;#34;, true}, {&amp;#34;a&amp;#34;, true}, {&amp;#34;aa&amp;#34;, true}, {&amp;#34;ab&amp;#34;, false}, {&amp;#34;aba&amp;#34;, true}, {&amp;#34;abcba&amp;#34;, true}, {&amp;#34;abccba&amp;#34;, true}, {&amp;#34;abcdabcd&amp;#34;, false}, {&amp;#34;Madam,I’mAdam&amp;#34;, false}, {&amp;#34;油灯少灯油&amp;#34;, true}, } for _, tc := range arr { t.</description></item><item><title>Goroutine 练习题</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/goroutine_exercise/</link><pubDate>Wed, 07 Sep 2022 14:50:29 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/goroutine_exercise/</guid><description>题目: 使用 goroutine 和 channel 实现一个计算int64随机数各位数和的程序，例如生成随机数61345，计算其每个位数上的数字之和为19。 开启一个 goroutine 循环生成int64类型的随机数，发送到 jobChan 开启24个 goroutine 从jobChan中取出随机数计算各位数的和，将结果发送到resultChan 主 goroutine 从resultChan取出结果并打印到终端输出 题目来源: 李文周blog
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;time&amp;#34; ) func main() { numChan := make(chan int, 24) resChan := make(chan int) for i := 0; i &amp;lt; 24; i++ { go func() { for num := range numChan { if check19(num) { resChan &amp;lt;- num break } } }() } FOR: for { select { case res := &amp;lt;-resChan: fmt.</description></item><item><title>Go | for...range 中 value 的地址</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_pointer_of_value_in_for_range/</link><pubDate>Wed, 31 Aug 2022 11:20:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_pointer_of_value_in_for_range/</guid><description>nums := []int{1, 2, 3} for i := 0; i &amp;lt; len(nums); i++ { fmt.Printf(&amp;#34;%p \n&amp;#34;, &amp;amp;nums[i]) } for index, num := range nums { fmt.Printf(&amp;#34;%p %p \n&amp;#34;, &amp;amp;nums[index], &amp;amp;num) } // 0xc00000c150 // 0xc00000c158 // 0xc00000c160 // 0xc0000180e0 0xc00000c150 // 0xc0000180e0 0xc00000c158 // 0xc0000180e0 0xc00000c160 由上可知, 有 for range 遍历中, value 的地址是固定的, 相当于初始化一个变量, 之后每次遍历会把 value 值赋值给该变量
题目: 请问下面代码的执行结果是什么？ 题目来源: liwenzhou-blog go语言基础之结构体
type student struct { name string age int } func main() { m := make(map[string]*student) stus := []student{ {name: &amp;#34;小王子&amp;#34;, age: 18}, {name: &amp;#34;娜扎&amp;#34;, age: 23}, {name: &amp;#34;大王八&amp;#34;, age: 9000}, } for _, stu := range stus { m[stu.</description></item><item><title>Go 中 make 与 new 的区别</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_difference_between_new_and_make/</link><pubDate>Wed, 31 Aug 2022 09:01:20 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_difference_between_new_and_make/</guid><description>背景: 在 go 中, 基本类型的变量, 在使用var定义变量, 但是初始化值时, 系统会默认赋初始值, 如 string =&amp;gt; &amp;ldquo;&amp;quot;(空字符串), int =&amp;gt; 0, bool =&amp;gt; false, 如果是 struct, 也会按 field 的类型(要求 field 的类型也为基本类型)进行初始化
对于 slice, map, channel 这三种类型, 使用 var 定义类型后, 其值为 nil, 不占内存, 所以需要先分配内存, 不能只定义类型后就直接赋值
// map 初始化 map1 := make(map[string]string) // 推荐 map2 := map[string]string{} fmt.Printf(&amp;#34;%#v\n&amp;#34;, map1) fmt.Printf(&amp;#34;%#v\n&amp;#34;, map2) // slice 初始化 slice1 := make([]int, 0) slice1 = append(slice1, 1) var slice2 []int slice2 = append(slice2, 1) slice3 := []int{} // 不推荐 slice3 = append(slice3, 1) fmt.</description></item><item><title>Go Defer Return 题 - 李文周</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_defer_return_%E9%A2%98%E6%9D%8E%E6%96%87%E5%91%A8/</link><pubDate>Tue, 30 Aug 2022 15:14:25 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_defer_return_%E9%A2%98%E6%9D%8E%E6%96%87%E5%91%A8/</guid><description>题1: 阅读下面的代码，写出最后的打印结果 来源: 李文周blog - go语言基础之函数
return res 底层实现:
返回值 = x, 如果函数中已定义返回变量名, 则该返回变量 = x 执行返回 遇到 defer 时 return res 底层实现
返回值 = x. 如果函数中已定义返回变量名, 则该返回变量 = x; 如果函数中未指定返回变量名, 则假定返回变量名为 returnValue, 也就有 returnValue = x 执行 defer 的函数 执行 返回 func f1() int { x := 5 defer func() { x++ }() return x } func f2() (x int) { defer func() { x++ }() return 5 } func f3() (y int) { x := 5 defer func() { x++ }() return x } func f4() (x int) { defer func(x int) { x++ }(x) return 5 } func main() { fmt.</description></item><item><title>Go slice 底层数组题</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E9%A2%98/</link><pubDate>Tue, 30 Aug 2022 11:25:55 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E9%A2%98/</guid><description>请写出下面代码的输出结果 ⭐⭐⭐⭐
func main() { type Map map[string][]int m := make(Map) s := []int{1, 2} s = append(s, 3) fmt.Printf(&amp;#34;%+v\n&amp;#34;, s) m[&amp;#34;q1mi&amp;#34;] = s s = append(s[:1], s[2:]...) fmt.Printf(&amp;#34;%+v\n&amp;#34;, s) fmt.Printf(&amp;#34;%+v\n&amp;#34;, m[&amp;#34;q1mi&amp;#34;]) } 问题简化为
s := []int{1, 2, 3} s2 := s fmt.Println(s, s2) s = append(s[:1], s[2:]...) fmt.Println(s, s2) 点击查看 result:
[1 2 3] [1 2 3]
[1 3] [1 3 3]</description></item><item><title>Go slice 写出代码的运行结果</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</link><pubDate>Mon, 29 Aug 2022 16:34:55 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</guid><description>请写出下面代码的输出结果 func main() { var a = make([]string, 5, 10) for i := 0; i &amp;lt; 10; i++ { a = append(a, fmt.Sprintf(&amp;#34;%v&amp;#34;, i)) } fmt.Println(a) } 点击查看 make 后 a 已经初始化为 []string{&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;}
之后再 append, 会添加到后面 []string{&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;4&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;ldquo;6&amp;rdquo;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,9&amp;quot;}</description></item><item><title>Find the only number in a list</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/find_the_only_number_in_a_list/</link><pubDate>Mon, 29 Aug 2022 10:12:23 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/find_the_only_number_in_a_list/</guid><description>题: 有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？ 来源: 李文周 Go语言基础之运算符
利用 ^ 二进位异或 运算符
func findTheOnlyNumber(nums []int) (res int) { for index, num := range nums { if index == 0 { res = num } else { res = res ^ num } } return }</description></item><item><title>Number of Chinese in a String</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/number-of-chinese-in-a-string/</link><pubDate>Fri, 26 Aug 2022 16:18:04 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/number-of-chinese-in-a-string/</guid><description>题目: 编写代码统计出字符串&amp;quot;hello沙河小王子&amp;quot;中汉字的数量 题目来源: 李文周blog: Go语言基础之基本数据类型
tips:
字符串用 for 遍历, str[i] 的值是 byte(uint8) 类型, 且下标 i 是连续的, 从 0 到 len(str) 字符串用 for range 遍历, index,value 的值是 rune(int32) 类型, 下标不一定是连续的, 碰到中文只会出现中文的首下标, 然后跳到下一个 rune 字符 func getChineseCharNumInAString(str string) (num int) { for i, r := range str { if byte(r) == str[i] { continue } num++ } return num }</description></item></channel></rss>