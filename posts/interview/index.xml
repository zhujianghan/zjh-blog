<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interview | Posts on Fourleaf Blog</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/</link><description>Recent content in Interview | Posts on Fourleaf Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 31 Aug 2022 09:01:20 +0800</lastBuildDate><atom:link href="https://zhujianghan.github.io/zjh-blog/posts/interview/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 中 make 与 new 的区别</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_difference_between_new_and_make/</link><pubDate>Wed, 31 Aug 2022 09:01:20 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_difference_between_new_and_make/</guid><description>背景: 在 go 中, 基本类型的变量, 在使用var定义变量, 但是初始化值时, 系统会默认赋初始值, 如 string =&amp;gt; &amp;ldquo;&amp;quot;(空字符串), int =&amp;gt; 0, bool =&amp;gt; false, 如果是 struct, 也会按 field 的类型(要求 field 的类型也为基本类型)进行初始化
对于 slice, map, channel 这三种类型, 使用 var 定义类型后, 其值为 nil, 不占内存, 所以需要先分配内存, 不能只定义类型后就直接赋值
// map 初始化 map1 := make(map[string]string) // 推荐 map2 := map[string]string{} fmt.Printf(&amp;#34;%#v\n&amp;#34;, map1) fmt.Printf(&amp;#34;%#v\n&amp;#34;, map2) // slice 初始化 slice1 := make([]int, 0) slice1 = append(slice1, 1) var slice2 []int slice2 = append(slice2, 1) slice3 := []int{} // 不推荐 slice3 = append(slice3, 1) fmt.</description></item><item><title>Go Defer Return 题 - 李文周</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_defer_return_%E9%A2%98%E6%9D%8E%E6%96%87%E5%91%A8/</link><pubDate>Tue, 30 Aug 2022 15:14:25 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_defer_return_%E9%A2%98%E6%9D%8E%E6%96%87%E5%91%A8/</guid><description>题1: 阅读下面的代码，写出最后的打印结果 来源: 李文周blog - go语言基础之函数
return res 底层实现:
返回值 = x, 如果函数中已定义返回变量名, 则该返回变量 = x 执行返回 遇到 defer 时 return res 底层实现
返回值 = x. 如果函数中已定义返回变量名, 则该返回变量 = x; 如果函数中未指定返回变量名, 则假定返回变量名为 returnValue, 也就有 returnValue = x 执行 defer 的函数 执行 返回 func f1() int { x := 5 defer func() { x++ }() return x } func f2() (x int) { defer func() { x++ }() return 5 } func f3() (y int) { x := 5 defer func() { x++ }() return x } func f4() (x int) { defer func(x int) { x++ }(x) return 5 } func main() { fmt.</description></item><item><title>Go slice 底层数组题</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E9%A2%98/</link><pubDate>Tue, 30 Aug 2022 11:25:55 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E9%A2%98/</guid><description>请写出下面代码的输出结果 ⭐⭐⭐⭐
func main() { type Map map[string][]int m := make(Map) s := []int{1, 2} s = append(s, 3) fmt.Printf(&amp;#34;%+v\n&amp;#34;, s) m[&amp;#34;q1mi&amp;#34;] = s s = append(s[:1], s[2:]...) fmt.Printf(&amp;#34;%+v\n&amp;#34;, s) fmt.Printf(&amp;#34;%+v\n&amp;#34;, m[&amp;#34;q1mi&amp;#34;]) } 问题简化为
s := []int{1, 2, 3} s2 := s fmt.Println(s, s2) s = append(s[:1], s[2:]...) fmt.Println(s, s2) 点击查看 result: [1 2 3] [1 2 3] [1 3] [1 3 3]</description></item><item><title>Go slice 写出代码的运行结果</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</link><pubDate>Mon, 29 Aug 2022 16:34:55 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</guid><description>请写出下面代码的输出结果 func main() { var a = make([]string, 5, 10) for i := 0; i &amp;lt; 10; i++ { a = append(a, fmt.Sprintf(&amp;#34;%v&amp;#34;, i)) } fmt.Println(a) } 点击查看 make 后 a 已经初始化为 []string{"","","","",""} 之后再 append, 会添加到后面 []string{"","","","","","0","1","2","3","4","5","6","7","8",9"}</description></item><item><title>Find the only number in a list</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/find_the_only_number_in_a_list/</link><pubDate>Mon, 29 Aug 2022 10:12:23 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/find_the_only_number_in_a_list/</guid><description>题: 有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？ 来源: 李文周 Go语言基础之运算符
利用 ^ 二进位异或 运算符
func findTheOnlyNumber(nums []int) (res int) { for index, num := range nums { if index == 0 { res = num } else { res = res ^ num } } return }</description></item><item><title>Number of Chinese in a String</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/number-of-chinese-in-a-string/</link><pubDate>Fri, 26 Aug 2022 16:18:04 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/number-of-chinese-in-a-string/</guid><description>题目: 编写代码统计出字符串&amp;quot;hello沙河小王子&amp;quot;中汉字的数量 题目来源: 李文周blog: Go语言基础之基本数据类型
tips:
字符串用 for 遍历, str[i] 的值是 byte(uint8) 类型, 且下标 i 是连续的, 从 0 到 len(str) 字符串用 for range 遍历, index,value 的值是 rune(int32) 类型, 下标不一定是连续的, 碰到中文只会出现中文的首下标, 然后跳到下一个 rune 字符 func getChineseCharNumInAString(str string) (num int) { for i, r := range str { if byte(r) == str[i] { continue } num++ } return num }</description></item></channel></rss>