<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on Fourleaf Blog</title><link>https://zhujianghan.github.io/zjh-blog/tags/go/</link><description>Recent content in go on Fourleaf Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Sep 2022 17:25:46 +0800</lastBuildDate><atom:link href="https://zhujianghan.github.io/zjh-blog/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Exercise_go_test_是否回文</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/exercise_go_test_palindrome/</link><pubDate>Fri, 09 Sep 2022 17:25:46 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/exercise_go_test_palindrome/</guid><description>编写一个回文检测函数，并为其编写单元测试和基准测试，根据测试的结果逐步对其进行优化。（回文：一个字符串正序和逆序一样，如“Madam,I’mAdam”、“油灯少灯油”等。） 来源:李文周blog
tip: 要考虑中文则使用 rune
// palindrome/palindrome.go package palindrome func IsPalindrome(s string) bool { // 转成 rune, 应对中文等特殊字符 r := []rune(s) l := len(r) for i := 0; i &amp;lt; l/2; i++ { if r[i] != r[l-1-i] { return false } } return true } // palindrome/palindrome_test.go package palindrome import ( &amp;#34;fmt&amp;#34; &amp;#34;testing&amp;#34; ) func TestIsPalindrome(t *testing.T) { type test struct { text string want bool } arr := []test{ {&amp;#34;&amp;#34;, true}, {&amp;#34;a&amp;#34;, true}, {&amp;#34;aa&amp;#34;, true}, {&amp;#34;ab&amp;#34;, false}, {&amp;#34;aba&amp;#34;, true}, {&amp;#34;abcba&amp;#34;, true}, {&amp;#34;abccba&amp;#34;, true}, {&amp;#34;abcdabcd&amp;#34;, false}, {&amp;#34;Madam,I’mAdam&amp;#34;, false}, {&amp;#34;油灯少灯油&amp;#34;, true}, } for _, tc := range arr { t.</description></item><item><title>Goroutine 练习题</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/goroutine_exercise/</link><pubDate>Wed, 07 Sep 2022 14:50:29 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/goroutine_exercise/</guid><description>题目: 使用 goroutine 和 channel 实现一个计算int64随机数各位数和的程序，例如生成随机数61345，计算其每个位数上的数字之和为19。 开启一个 goroutine 循环生成int64类型的随机数，发送到 jobChan 开启24个 goroutine 从jobChan中取出随机数计算各位数的和，将结果发送到resultChan 主 goroutine 从resultChan取出结果并打印到终端输出 题目来源: 李文周blog
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;time&amp;#34; ) func main() { numChan := make(chan int, 24) resChan := make(chan int) for i := 0; i &amp;lt; 24; i++ { go func() { for num := range numChan { if check19(num) { resChan &amp;lt;- num break } } }() } FOR: for { select { case res := &amp;lt;-resChan: fmt.</description></item><item><title>Go | for...range 中 value 的地址</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_pointer_of_value_in_for_range/</link><pubDate>Wed, 31 Aug 2022 11:20:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_pointer_of_value_in_for_range/</guid><description>nums := []int{1, 2, 3} for i := 0; i &amp;lt; len(nums); i++ { fmt.Printf(&amp;#34;%p \n&amp;#34;, &amp;amp;nums[i]) } for index, num := range nums { fmt.Printf(&amp;#34;%p %p \n&amp;#34;, &amp;amp;nums[index], &amp;amp;num) } // 0xc00000c150 // 0xc00000c158 // 0xc00000c160 // 0xc0000180e0 0xc00000c150 // 0xc0000180e0 0xc00000c158 // 0xc0000180e0 0xc00000c160 由上可知, 有 for range 遍历中, value 的地址是固定的, 相当于初始化一个变量, 之后每次遍历会把 value 值赋值给该变量
题目: 请问下面代码的执行结果是什么？ 题目来源: liwenzhou-blog go语言基础之结构体
type student struct { name string age int } func main() { m := make(map[string]*student) stus := []student{ {name: &amp;#34;小王子&amp;#34;, age: 18}, {name: &amp;#34;娜扎&amp;#34;, age: 23}, {name: &amp;#34;大王八&amp;#34;, age: 9000}, } for _, stu := range stus { m[stu.</description></item><item><title>Go 中 make 与 new 的区别</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_difference_between_new_and_make/</link><pubDate>Wed, 31 Aug 2022 09:01:20 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_difference_between_new_and_make/</guid><description>背景: 在 go 中, 基本类型的变量, 在使用var定义变量, 但是初始化值时, 系统会默认赋初始值, 如 string =&amp;gt; &amp;ldquo;&amp;quot;(空字符串), int =&amp;gt; 0, bool =&amp;gt; false, 如果是 struct, 也会按 field 的类型(要求 field 的类型也为基本类型)进行初始化
对于 slice, map, channel 这三种类型, 使用 var 定义类型后, 其值为 nil, 不占内存, 所以需要先分配内存, 不能只定义类型后就直接赋值
// map 初始化 map1 := make(map[string]string) // 推荐 map2 := map[string]string{} fmt.Printf(&amp;#34;%#v\n&amp;#34;, map1) fmt.Printf(&amp;#34;%#v\n&amp;#34;, map2) // slice 初始化 slice1 := make([]int, 0) slice1 = append(slice1, 1) var slice2 []int slice2 = append(slice2, 1) slice3 := []int{} // 不推荐 slice3 = append(slice3, 1) fmt.</description></item><item><title>Go Defer Return 题 - 李文周</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_defer_return_%E9%A2%98%E6%9D%8E%E6%96%87%E5%91%A8/</link><pubDate>Tue, 30 Aug 2022 15:14:25 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_defer_return_%E9%A2%98%E6%9D%8E%E6%96%87%E5%91%A8/</guid><description>题1: 阅读下面的代码，写出最后的打印结果 来源: 李文周blog - go语言基础之函数
return res 底层实现:
返回值 = x, 如果函数中已定义返回变量名, 则该返回变量 = x 执行返回 遇到 defer 时 return res 底层实现
返回值 = x. 如果函数中已定义返回变量名, 则该返回变量 = x; 如果函数中未指定返回变量名, 则假定返回变量名为 returnValue, 也就有 returnValue = x 执行 defer 的函数 执行 返回 func f1() int { x := 5 defer func() { x++ }() return x } func f2() (x int) { defer func() { x++ }() return 5 } func f3() (y int) { x := 5 defer func() { x++ }() return x } func f4() (x int) { defer func(x int) { x++ }(x) return 5 } func main() { fmt.</description></item><item><title>Go slice 底层数组题</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E9%A2%98/</link><pubDate>Tue, 30 Aug 2022 11:25:55 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E9%A2%98/</guid><description>请写出下面代码的输出结果 ⭐⭐⭐⭐
func main() { type Map map[string][]int m := make(Map) s := []int{1, 2} s = append(s, 3) fmt.Printf(&amp;#34;%+v\n&amp;#34;, s) m[&amp;#34;q1mi&amp;#34;] = s s = append(s[:1], s[2:]...) fmt.Printf(&amp;#34;%+v\n&amp;#34;, s) fmt.Printf(&amp;#34;%+v\n&amp;#34;, m[&amp;#34;q1mi&amp;#34;]) } 问题简化为
s := []int{1, 2, 3} s2 := s fmt.Println(s, s2) s = append(s[:1], s[2:]...) fmt.Println(s, s2) 点击查看 result:
[1 2 3] [1 2 3]
[1 3] [1 3 3]</description></item><item><title>Go slice 写出代码的运行结果</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</link><pubDate>Mon, 29 Aug 2022 16:34:55 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/go_slice_%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</guid><description>请写出下面代码的输出结果 func main() { var a = make([]string, 5, 10) for i := 0; i &amp;lt; 10; i++ { a = append(a, fmt.Sprintf(&amp;#34;%v&amp;#34;, i)) } fmt.Println(a) } 点击查看 make 后 a 已经初始化为 []string{&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;}
之后再 append, 会添加到后面 []string{&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;4&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;ldquo;6&amp;rdquo;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,9&amp;quot;}</description></item><item><title>Find the only number in a list</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/find_the_only_number_in_a_list/</link><pubDate>Mon, 29 Aug 2022 10:12:23 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/find_the_only_number_in_a_list/</guid><description>题: 有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？ 来源: 李文周 Go语言基础之运算符
利用 ^ 二进位异或 运算符
func findTheOnlyNumber(nums []int) (res int) { for index, num := range nums { if index == 0 { res = num } else { res = res ^ num } } return }</description></item><item><title>Number of Chinese in a String</title><link>https://zhujianghan.github.io/zjh-blog/posts/interview/number-of-chinese-in-a-string/</link><pubDate>Fri, 26 Aug 2022 16:18:04 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/interview/number-of-chinese-in-a-string/</guid><description>题目: 编写代码统计出字符串&amp;quot;hello沙河小王子&amp;quot;中汉字的数量 题目来源: 李文周blog: Go语言基础之基本数据类型
tips:
字符串用 for 遍历, str[i] 的值是 byte(uint8) 类型, 且下标 i 是连续的, 从 0 到 len(str) 字符串用 for range 遍历, index,value 的值是 rune(int32) 类型, 下标不一定是连续的, 碰到中文只会出现中文的首下标, 然后跳到下一个 rune 字符 func getChineseCharNumInAString(str string) (num int) { for i, r := range str { if byte(r) == str[i] { continue } num++ } return num }</description></item><item><title>Buffer-String()-和-Buffer-String()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/buffer-string-%E5%92%8C-buffer-string/</link><pubDate>Thu, 16 Jun 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/buffer-string-%E5%92%8C-buffer-string/</guid><description>b1 := bytes.Buffer{} // 非指针 b2 := bytes.NewBuffer([]byte{}) // 指针 b3 := &amp;amp;bytes.Buffer{} // 指针, 等同于 b2 b1.WriteString(&amp;#34;abc&amp;#34;) b2.WriteString(&amp;#34;abc&amp;#34;) fmt.Println(b1) // {[97 98 99] 0 0} fmt.Println(b1.String()) // abc fmt.Println(b2) // abc 原因: *Buffer 有方法 String(), Buffer 没有 String() 方法.
fmt.Println(b1), 就是 fmt 将 b1 按普通结构体进行输出: 分别输出各项 fmt.Println(b1.String()), 调用了 *Buffer 的 String() 方法 fmt.Println(b2), 自动调用 *Buffer 的 String() 方法 参考自 stackoverflow</description></item><item><title>gin-middleware-注意事项</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/gin-middleware-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Tue, 07 Jun 2022 14:49:09 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/gin-middleware-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>1. gin middleware 如果要中止后面中间件及所有程序的执行, 需要使用 c.Abort() + return 其中 Abort 会中止其后的中间件及页面处理程序, 而不会中止当前中间件函数内的余下程序, 使用 return 来中止当前中间件内后部的程序 func RejectMethodsExceptGet() gin.HandlerFunc { rejectMethods := map[string]struct{}{ &amp;#34;POST&amp;#34;: {}, &amp;#34;DELETE&amp;#34;: {}, &amp;#34;PUT&amp;#34;: {}, &amp;#34;PATCH&amp;#34;: {}, } return func(c *gin.Context) { if _, exist := rejectMethods[c.Request.Method]; exist { c.AbortWithStatusJSON(403, gin.H{ &amp;#34;err_msg&amp;#34;: &amp;#34;invalid method&amp;#34;, }) return } c.Next() } } 2. 中间件 Use 需要写在路由注册之前, 否则将不对之前注册的路由起作用 r := gin.New() r.Use(RejectMethodsExceptGet()) r.GET(&amp;#34;/test&amp;#34;, func(c *gin.Context) { example := c.MustGet(&amp;#34;example&amp;#34;).(string) // it would print: &amp;#34;12345&amp;#34; log.</description></item><item><title>go-routine-使用外部变量问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-routine-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 26 Apr 2022 10:28:36 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-routine-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</guid><description>for i := 0; i &amp;lt; 10; i++ { go func() { fmt.Println(i) } } time.Sleep(time.Second) // 10,10,10,10,... 使用 go vet 检查
// 修改 for i := 0; i &amp;lt; 10; i++ { go func() { i2 := i fmt.Println(i2) } } // 或者(推荐) for i := 0; i &amp;lt; 10; i++ { go func(i int) { fmt.Println(i) }(i) } time.Sleep(time.Second) 参考 https://www.jianshu.com/p/e5f328819d4b</description></item><item><title>go-通用-http-client-请求头</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E9%80%9A%E7%94%A8-http-client-%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E9%80%9A%E7%94%A8-http-client-%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>参考stackoverflow: adding-a-default-http-header-in-go
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) const accessToken = &amp;#34;MY_DEMO_TOKEN&amp;#34; type MyRoundTripper struct { r http.RoundTripper } func (mrt MyRoundTripper) RoundTrip(r *http.Request) (*http.Response, error) { r.Header.Add(&amp;#34;Authorization&amp;#34;, &amp;#34;Bearer: &amp;#34;+accessToken) return mrt.r.RoundTrip(r) } func main() { client := &amp;amp;http.Client{ Timeout: time.Second * 10, Transport: MyRoundTripper{r: http.DefaultTransport}, } fmt.Println(client.Get(&amp;#34;http://google.com/&amp;#34;)) }</description></item><item><title>json-Unmarshal-如何获取-null</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/json-unmarshal-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-null/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/json-unmarshal-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-null/</guid><description>对于如下 json 和 struct, 会将 gender 解析为 false, 而实际上应为 nil, 则需要 将 struct 中的 bool 类型转为 *bool 类型
{ &amp;#34;name&amp;#34;: &amp;#34;Jim Green&amp;#34;, &amp;#34;age&amp;#34;: 15, &amp;#34;gender&amp;#34;: null } type Student struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` Name bool `json:&amp;#34;gender&amp;#34;` } 因为在 go 中指针不可以进行运算, 只能引用 对于 *bool 类型的变量, 不能直接赋值 如
var gender *bool *gender = true // panic: runtime error: invalid memory address or nil pointer dereference 而应该对非指针类型赋值, 再引用指针
var gender *bool tempGender := true gender = &amp;amp;tempGender</description></item><item><title>middleware-gin-contrib-cors-在-301-时失效</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/middleware-gin-contrib-cors-%E5%9C%A8-301-%E6%97%B6%E5%A4%B1%E6%95%88/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/middleware-gin-contrib-cors-%E5%9C%A8-301-%E6%97%B6%E5%A4%B1%E6%95%88/</guid><description>背景: gin 配置了路由 router.GET(&amp;quot;/api/users&amp;quot;) , 添加了 cors 中间件, 但是访问 /api/users/ 时, 会返回 301 + cros 错误
原因: gin 默认打开 &amp;ldquo;RedirectTrailingSlash&amp;rdquo;, 表示自动添加(或删除) &amp;ldquo;/&amp;rdquo; 并作 301 跳转, 这时候还未进入 middleware, 所以 cors 中间件所添加的 header 不会出现在返回头中.
中间件其它现象:
c.Header(&amp;#34;before-next&amp;#34;: &amp;#34;can-be-show&amp;#34;) // 会写入到返回头 c.next() c.Header(&amp;#34;after-next&amp;#34;: &amp;#34;won&amp;#39;t be returned&amp;#34;) // 不会出现在返回头中 解决办法:
在 gin 路由中同时添加 带 / 和不带 / 的路由, 工作量大, 且 ugly ❌ 使用 nginx 在 go-web 程序外部直接全部带上 cors 头 ✅</description></item><item><title>supervisor-unix----tmp-supervisor-sock-no-such-file</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/supervisor-unix----tmp-supervisor-sock-no-such-file/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/supervisor-unix----tmp-supervisor-sock-no-such-file/</guid><description>[root@iZm5e09hymnzdmgx3964zgZ etc]# cat -n supervisord.conf | grep /tmp -- 22 [unix_http_server] 23 ;file=/tmp/supervisor.sock ; the path to the socket file 24 file=/var/run/supervisor.sock ; the path to the socket file -- 45 [supervisord] 46 ;logfile=/tmp/supervisord.log ; main log file; default $CWD/supervisord.log 47 logfile=/var/log/supervisord.log ; main log file; default $CWD/supervisord.log -- 50 loglevel=info ; log level; default info; others: debug,warn,trace 51 ;pidfile=/tmp/supervisord.pid ; supervisord pidfile; default supervisord.pid 52 pidfile=/var/run/supervisord.pid ; supervisord pidfile; default supervisord.</description></item><item><title>go-自定义-struct-转-json</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E8%87%AA%E5%AE%9A%E4%B9%89-struct-%E8%BD%AC-json/</link><pubDate>Thu, 14 Apr 2022 16:13:08 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E8%87%AA%E5%AE%9A%E4%B9%89-struct-%E8%BD%AC-json/</guid><description>需求: 从 api 获取到 json, 本地 unmarshal 为 struct 后, 以另外的 json tag marhsal 为 json 字符串 type Student struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` } strIn := `{ &amp;#34;stu_name&amp;#34;: &amp;#34;Jim Green&amp;#34;, &amp;#34;age&amp;#34;: 14 }` // to json strOut := `{ &amp;#34;name&amp;#34;: &amp;#34;Jim Green&amp;#34;, &amp;#34;age&amp;#34;: 14 }` 使用到的方法 UmarshalJOSN / MarshalJSON
方法一: 通过中间 struct 变量的匿名嵌套 struct embedding (注意防止无限循环使用 alias) package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type Student struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` } func (s *Student) UnmarshalJSON(data []byte) error { type Alias Student aux := &amp;amp;struct { *Alias StuName string `json:&amp;#34;stu_name&amp;#34;` }{ Alias: (*Alias)(s), } if err := json.</description></item><item><title>go-判断-https-ssl-证书是否过期</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E5%88%A4%E6%96%AD-https-ssl-%E8%AF%81%E4%B9%A6%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F/</link><pubDate>Fri, 25 Mar 2022 13:03:46 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E5%88%A4%E6%96%AD-https-ssl-%E8%AF%81%E4%B9%A6%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F/</guid><description>package main import ( &amp;#34;crypto/tls&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { conn, err := tls.Dial(&amp;#34;tcp&amp;#34;, &amp;#34;blog.umesh.wtf:443&amp;#34;, nil) if err != nil { panic(&amp;#34;Server doesn&amp;#39;t support SSL certificate err: &amp;#34; + err.Error()) } err = conn.VerifyHostname(&amp;#34;blog.umesh.wtf&amp;#34;) if err != nil { panic(&amp;#34;Hostname doesn&amp;#39;t match with certificate: &amp;#34; + err.Error()) } expiry := conn.ConnectionState().PeerCertificates[0].NotAfter fmt.Printf(&amp;#34;Issuer: %s\nExpiry: %v\n&amp;#34;, conn.ConnectionState().PeerCertificates[0].Issuer, expiry.Format(time.RFC850)) } 参考自 freecodecamp</description></item><item><title>删除文件夹中的node_modules子文件夹</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84node_modules%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</link><pubDate>Sat, 18 Sep 2021 10:12:01 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84node_modules%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</guid><description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;io/fs&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path&amp;#34; &amp;#34;path/filepath&amp;#34; ) func main() { if len(os.Args) == 1 { panic(&amp;#34;Enter a file name&amp;#34;) } src := os.Args[1] var pathList []string err := filepath.Walk(src, func(path string, info fs.FileInfo, err error) error { if err != nil { return err } if info.IsDir() &amp;amp;&amp;amp; info.Name() == &amp;#34;node_modules&amp;#34; { return filepath.SkipDir } if info.IsDir() { return nil } path = filepath.ToSlash(path) pathList = append(pathList, path) return nil }) if err !</description></item><item><title>centos-部署-go-web</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/centos-%E9%83%A8%E7%BD%B2-go-web/</link><pubDate>Fri, 17 Sep 2021 09:27:47 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/centos-%E9%83%A8%E7%BD%B2-go-web/</guid><description>编译后的文件上传至服务器, 有两个事情要做, 一是把 web 应用做成守护进程启动, 二是端口开放
使用纯净 centos7 环境(justhost.ru vps, 非阿里云环境)
1. 防火墙开放端口 1.1 查看防火墙状态
firewall-cmd --state # running 1.2 如果没有开启, 启动防火墙
systemctl start firewalld.service 1.3 开放 8080 端口
firewall-cmd --zone=public --add-port=8080/tcp --permanent # 开放多个端口 firewall-cmd --add-port=8081-8100/tcp --permanent 1.4 重启防火墙
systemctl restart firewall.service 1.5 重载配置
firewall-cmd --realod 1.6 查看端口开启情况
netstat -nltp # 或者使用 firewall-cmd 查看 # 查看所有 firewall-cmd --list-all # 查看指定 firewall-cmd --query-port=8080/tcp 1.7 移除端口
firewall-cmd --remove-port=8080/tcp --permanent 2. supervisord 守护进程 2.</description></item><item><title>go-结构体实例化</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%8C%96/</link><pubDate>Fri, 16 Jul 2021 10:21:06 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%8C%96/</guid><description>type Block struct { length int height int } // 方式一 var a Block a.length = 1 a.height = 2 // 方式二 b := Block{1, 2} // 方式三 c := &amp;amp;Block{1, 2} // 方式四 d := new(Block) d.length = 1 d.height = 2 fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) 方式一和二 相同, 结果都是 值对象 方式三和四 相同, 结果都是指针
值和指针的不同点在于, 如果需要对 结构体的实例进行修改时, 值需要加上 &amp;amp;, 而 指针不需要
如果一个 struct 内容很多, 占用内存大, 应该使用 指针而不是值来进行函数间的传递.
参考 segmentfault cnblog</description></item><item><title>goland-import-包报红</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/goland-import-%E5%8C%85%E6%8A%A5%E7%BA%A2/</link><pubDate>Fri, 19 Feb 2021 09:52:51 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/goland-import-%E5%8C%85%E6%8A%A5%E7%BA%A2/</guid><description>在使用 go mod 后(go 1.11 开始支持, go 1.14 全面推荐), 无需在 GOPATH 的 src 下存在项目目录, 可以随意存放.
go 包依赖管理 gopath &amp;gt; go vender &amp;gt; go module, 参考 # 一文搞懂 Go Modules 前世今生及入门使用
GOPATH 则只存放第三方包, 若不设置, 默认为 /[user]/go 目录
goland 配置 GOROOT, GOPATH 及 Go Modules
结果会在 External Libraries 中多出一个 Go Modules</description></item><item><title>golang-删除-slice-中的部分元素</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/golang-%E5%88%A0%E9%99%A4-slice-%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 08 Nov 2019 16:08:40 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/golang-%E5%88%A0%E9%99%A4-slice-%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0/</guid><description>golang 对 slice 的操作全在 [:] 中 和 append
// 删除切片的第三个元素 sslice := []int{0,1,2,3,4} sslice = append(sslice[:2], sslice[3:]...) Notice
sslice[A:B], 包涵 A, 不包括 B; 若 A = B,包涵 A append 第一个参数为 切片, 第二(三,四)个参数为 元素, 若为 切片, 可以使用 &amp;hellip; 分解 (析构) 为元素</description></item><item><title>golang-给-struct-赋值-nil</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/golang-%E7%BB%99-struct-%E8%B5%8B%E5%80%BC-nil/</link><pubDate>Fri, 08 Nov 2019 15:28:22 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/golang-%E7%BB%99-struct-%E8%B5%8B%E5%80%BC-nil/</guid><description>struct ListNode { Val int Next *ListNode } var li *ListNode = nil 原文见csdn</description></item><item><title>go-环境变量设置-proxy</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE-proxy/</link><pubDate>Wed, 06 Nov 2019 17:08:15 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/go-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE-proxy/</guid><description>Go version &amp;gt;= 1.13 当你的GO的版本大于1.13的时候 当你安装的GO的语言版本大于1.13的时候，那么就不用这么麻烦了，直接使用go env -w命令就行了
go env -w GOPROXY=https://goproxy.io,direct go env -w GOPRIVATE=*.corp.example.com go env -w GO111MODULE=on 转自掘金</description></item></channel></rss>