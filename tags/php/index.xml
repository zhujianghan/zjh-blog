<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>php on Fourleaf Blog</title><link>https://zhujianghan.github.io/zjh-blog/tags/php/</link><description>Recent content in php on Fourleaf Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 16 Apr 2022 11:29:14 +0800</lastBuildDate><atom:link href="https://zhujianghan.github.io/zjh-blog/tags/php/index.xml" rel="self" type="application/rss+xml"/><item><title>$_ENV-&amp;-getenv()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/_env--getenv/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/_env--getenv/</guid><description>php 中 $_ENV &amp;amp; getenv() 获取的是环境变量, 如 windows 中 高级系统设置中的环境变量 或 linux 中 export 设置
getenv() 或 $_ENV 获取的是(系统)环境变量, 而不是 .env 文件.
在默认variables_order = &amp;quot;GPCS&amp;quot; 时, laravel 中使用 $_ENV 不能获取到(系统)环境变量, 但是可以获取到 .env 中的变量, 是因为 laravel 在初始化时使用 phpdotenv 将 .env 中的值添加到 $_ENV 中了.
另外 laravel 中 getenv() 本来就可以获取到(系统)环境变量, 也可以获取到 .env 文件中的设置的环境变量, 是因为 laravel(phpdotenv) 用 putenv() 设置了请求期间内有效的环境变量.
ini_set() 配置可修改范围 参考php手册 laravel 初始化 dotenv 参考文章 Laravel ENV—— 环境变量的加载与源码解析</description></item><item><title>foreach-中使用-&amp;地址符时,-最后要释放-value</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/foreach-%E4%B8%AD%E4%BD%BF%E7%94%A8-%E5%9C%B0%E5%9D%80%E7%AC%A6%E6%97%B6-%E6%9C%80%E5%90%8E%E8%A6%81%E9%87%8A%E6%94%BE-value/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/foreach-%E4%B8%AD%E4%BD%BF%E7%94%A8-%E5%9C%B0%E5%9D%80%E7%AC%A6%E6%97%B6-%E6%9C%80%E5%90%8E%E8%A6%81%E9%87%8A%E6%94%BE-value/</guid><description>$arr = [1,2,3]; foreach($arr as $key=&amp;gt; &amp;amp;$value){ if ($key){ $value = $value +1; } } unset($value); // 要注意翻译 $value, 否则后面如果还要用到 $value 时, 会指向 $arr 的最后一个元素</description></item><item><title>guzzle-http-post-(json)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/guzzle-http-post-json/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/guzzle-http-post-json/</guid><description>$client = new \GuzzleHttp\Client(); $response = $client-&amp;gt;post(&amp;#39;http://xxx.com/api/login&amp;#39;, [ &amp;#39;json&amp;#39; =&amp;gt; [ &amp;#39;phone&amp;#39; =&amp;gt; &amp;#34;152xxxx1234&amp;#34;, &amp;#39;password&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34;, ] ]); $response = $client-&amp;gt;post(&amp;#39;http://xxx.com/api/login&amp;#39;, [ &amp;#39;form_params&amp;#39; =&amp;gt; [ &amp;#39;phone&amp;#39; =&amp;gt; &amp;#34;152xxxx1234&amp;#34;, &amp;#39;password&amp;#39; =&amp;gt; 123456, ] ]); 若使用 json, 则 数组中的值(不论是否数字), 都要用 引号 起来, 而 form_params 则不需要
reference</description></item><item><title>notes--基于-Composer-的-PHP-模块化开发</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/notes--%E5%9F%BA%E4%BA%8E-composer-%E7%9A%84-php-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/notes--%E5%9F%BA%E4%BA%8E-composer-%E7%9A%84-php-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</guid><description>笔记来源 overtrue: 基于 Composer 的 PHP 模块化开发
1. what &amp;amp; why composer 是 php 版本的版本控制工具, 如 js 里的 npm, go 里的 mod.
1.1 composer.json 的组成 基础字段 name, description, keywords, license 依赖 require, require-dev 自动加载: autoload, autoload-dev PSR-4 PSR-0 classmate files 其它 scripts, minimum-stability, bin, repositories, support, config 其中, 若是一个项目, name 表示 project name, 若是一个包, name 表示 package name
在没有 composer 之前, 靠人工复制粘贴代码, 存在代码安全及 repeat yourself 的问题
1.2 版本号的组成 Major.Minor.Patch
major: 大的功能变更, 不向后兼容 minor: 新增功能, 向后兼容 patch: 补丁, 向后兼容, 修复 bug 1.</description></item><item><title>php-类方法的连接调用-$this--where()--select()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B0%83%E7%94%A8-this--where--select/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B0%83%E7%94%A8-this--where--select/</guid><description>这种类方法最后都返回了 $this, 从而能连续调用;
至于中间的方法, 通过类属性将值保存起来, 可供后续方法继续使用</description></item><item><title>php-重写(override,-覆盖)-和-重载(overload)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E9%87%8D%E5%86%99override-%E8%A6%86%E7%9B%96-%E5%92%8C-%E9%87%8D%E8%BD%BDoverload/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E9%87%8D%E5%86%99override-%E8%A6%86%E7%9B%96-%E5%92%8C-%E9%87%8D%E8%BD%BDoverload/</guid><description> 重写: 子类继承父类时, 重写了方法 重载: 传统意义上的重载(如java), 指一个类中存在多个同名的方法, 但接收参数不一样, php 不支持这样的写法 php 提供的 overloading(重载), 指的是 动态地创建类属性和方法, 通过 魔术方法 来实现</description></item><item><title>phpoffice---phpword-写入文件不可打开</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/phpoffice---phpword-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8D%E5%8F%AF%E6%89%93%E5%BC%80/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/phpoffice---phpword-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8D%E5%8F%AF%E6%89%93%E5%BC%80/</guid><description>使用 phpword 的模板写入字符串时, 最后生成的文件打开失败.
这可能是因为 写入的文件内容没有 做 htmlspecialchars 处理, 而 docx 的 xml 不允许 &amp;amp;, &amp;lsquo;, &amp;ldquo;, &amp;lt;, &amp;gt; 字符, 这几样需要进行转义处理.</description></item><item><title>php中-utf-8-还是-utf8--</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E4%B8%AD-utf-8-%E8%BF%98%E6%98%AF-utf8--/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E4%B8%AD-utf-8-%E8%BF%98%E6%98%AF-utf8--/</guid><description>utf8、utf-8 和 UTF-8 的区别如下：
一、“UTF-8”这是标准写法，在PHP和HTML中设置编码，统一写成“UTF-8”。 举例： PHP中 —— HTML中　——　二、“utf8”、“utf-8”和“UTF8”只是在window中不区分大小写的写法而已，一般程序能识别，但也有例外。例如简写的“UTF8”或“utf8”在ie浏览器里不识别。
三、数据库命令模式中，必须写成“utf8”，因为MySQL的命令模式中只能识别“utf8”，比如：PHP程序中可以写： 结论：MySQL操作使用“utf8” 【mysql_query(set names utf8)】，其他一律使用“UTF-8”。
原文见: https://blog.csdn.net/ahjxhy2010/article/details/79722997</description></item><item><title>tp5-1-和-laravel-中的-facade-门面</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-1-%E5%92%8C-laravel-%E4%B8%AD%E7%9A%84-facade-%E9%97%A8%E9%9D%A2/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/tp5-1-%E5%92%8C-laravel-%E4%B8%AD%E7%9A%84-facade-%E9%97%A8%E9%9D%A2/</guid><description> facade 的作用是把 类(动态)方法 当作 静态方法 使用; 简称 静态代理
&amp;lt;?php class Demo { public function index(){ echo &amp;#39;hello world&amp;#39;; // echo __METHOD__; } } class DemoFacade { public static function __callStatic($name, $arguments) { $demo = new Demo(); $demo-&amp;gt;$name(); } } DemoFacade::index();// hello world</description></item><item><title>不间断空格-none-breaking-space-(-u00a0)</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%8D%E9%97%B4%E6%96%AD%E7%A9%BA%E6%A0%BC-none-breaking-space--u00a0/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%8D%E9%97%B4%E6%96%AD%E7%A9%BA%E6%A0%BC-none-breaking-space--u00a0/</guid><description>从网上复制的一些文本可能含有特殊字符, 不间断空格(unicode 编码为 \u00a0)就是一种, 效果与 &amp;rsquo; &amp;rsquo; 普通空格类似, 但有不同. 不同: 对英文单词间使用普通空格, 会自动换行; 使用不间断空格连接的单词会被认为是一个单词而直接全部换到下一行, 这在 html 也是同样的效果. 在 php 中使用 普通空格替换 不间断空格的方式
$str = &amp;#34;a a a&amp;#34;; $str = str_replace(chr( 194 ) . chr( 160 ), &amp;#34; &amp;#34;, $str); 参考自stackoverflow</description></item><item><title>如何减少-if---else----甚至-switch-的使用</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-if---else----%E7%94%9A%E8%87%B3-switch-%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-if---else----%E7%94%9A%E8%87%B3-switch-%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>需求: $str = &amp;#39;1,3,5&amp;#39;; // 变成 &amp;#39;abc,ghi,mno&amp;#39; $arr = [ [ &amp;#39;id&amp;#39;=&amp;gt;1, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;abc&amp;#39; ], [ &amp;#39;id&amp;#39;=&amp;gt;2, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;def&amp;#39; ], [ &amp;#39;id&amp;#39;=&amp;gt;3, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;ghi&amp;#39; ], [ &amp;#39;id&amp;#39;=&amp;gt;4, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;jkl&amp;#39; ], [ &amp;#39;id&amp;#39;=&amp;gt;5, &amp;#39;name&amp;#39;=&amp;gt;&amp;#39;mno&amp;#39; ], ]; 使用 if..else 或 switch 方法可以完成
现考虑不使用这两种方式作法:
思路: 把下面的 id 值作为键, name 值作为值, 重新构成一个数组 $arr2, 从 $str 中获取数字 如1, 使用 $arr2[&amp;lsquo;1&amp;rsquo;] 来获取对应的 name
php解法: // 1. 把当前 $arr 转成 目标数组 $arr2 $arr2 = []; foreach ($arr as $v) { $arr2[$v[&amp;#39;id&amp;#39;]] = $v[&amp;#39;name&amp;#39;]; } $str_to_arr = implode(&amp;#39;,&amp;#39;, $str);// [1,3,5] $str_to_arr = array_map(function(value){ return $arr2[&amp;#39;value&amp;#39;]; }) $str2 = join(&amp;#39;,&amp;#39;, $str_to_arr); JS 解法: js 只支持索引数组, 不支持关联数组, 但是 ES6 的 Map 对象支持任意的键或值 var str = &amp;#39;1,3,5&amp;#39;; var data = [ { id: 1, name: &amp;#39;中国&amp;#39; }, { id: 2, name: &amp;#39;美国&amp;#39; }, { id: 3, name: &amp;#39;日本&amp;#39; }, { id: 4, name: &amp;#39;韩国&amp;#39; }, { id: 5, name: &amp;#39;俄国&amp;#39; } ]; console.</description></item><item><title>一道小题--获取本月有多少天</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%80%E9%81%93%E5%B0%8F%E9%A2%98--%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%88%E6%9C%89%E5%A4%9A%E5%B0%91%E5%A4%A9/</link><pubDate>Sat, 16 Apr 2022 11:29:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E4%B8%80%E9%81%93%E5%B0%8F%E9%A2%98--%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%88%E6%9C%89%E5%A4%9A%E5%B0%91%E5%A4%A9/</guid><description>$today = &amp;#34;2018-8-8&amp;#34;; echo date(&amp;#39;t&amp;#39;,strtotime($today));// t 为本月天数, 28-31之间 // date() 函数可以直接得出, 避免了 复杂的判断 闰年,几月 等</description></item><item><title>php-进程线程</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</link><pubDate>Thu, 24 Feb 2022 13:25:15 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</guid><description>进程与线程的概念:
进程是 一个时间段: CPU 上下文切换之间的程序运行时 线程是进程之中的多个程序段的运行时, 线程共享进程的地址空间 (知乎: 线程和进程的区别是什么？)[https://www.zhihu.com/question/25532384]
php-fpm 是进程, 每个请求是单线程的 多个请求是并发(多线程)的</description></item><item><title>Duck-Type-鸭子类型</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/duck-type-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</link><pubDate>Wed, 23 Feb 2022 09:05:22 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/duck-type-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</guid><description>Duck Typing is a [type system] used in dynamic languages. For example, Python, Perl, Ruby, PHP, Javascript, etc. where the type or the class of an object is less important than the method it defines. Using Duck Typing, we do not check types at all. Instead, we check for the presence of a given method or attribute.
reference: geeksforgeeks
按上述来说, 鸭子类型是动态语言的特性, 在动态语言中, 类型并不重要, 重要的是类型(实例)的方法</description></item><item><title>php-生成文件流,-不生成本地文件</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E6%B5%81-%E4%B8%8D%E7%94%9F%E6%88%90%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 09 Feb 2021 09:36:18 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E6%B5%81-%E4%B8%8D%E7%94%9F%E6%88%90%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/</guid><description>$string = &amp;#34;I tried, honestly! 中文&amp;#34;; $stream = fopen(&amp;#39;data://text/plain,&amp;#39; . $string,&amp;#39;r&amp;#39;); //file_put_contents(&amp;#39;./a.txt&amp;#39;, $stream); //echo stream_get_contents($stream); echo $stream; $string = &amp;#39;Some bad-ass string&amp;#39;; $stream = fopen(&amp;#39;php://memory&amp;#39;,&amp;#39;r+&amp;#39;); fwrite($stream, $string); rewind($stream); echo stream_get_contents($stream); 参考自: Creating streams from strings in PHP</description></item><item><title>类的-static-及-self</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E7%B1%BB%E7%9A%84-static-%E5%8F%8A-self/</link><pubDate>Mon, 21 Dec 2020 10:26:59 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E7%B1%BB%E7%9A%84-static-%E5%8F%8A-self/</guid><description>使用 self:: 或者 CLASS 对当前类的静态引用，指向 定义当前方法所在的类.
使用 static 对当前类的静态引用，指向 使用当前方法所在的类.
参见php.net 后期静态绑定</description></item><item><title>php-的-session-文件</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%9A%84-session-%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 12 Oct 2020 15:34:47 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E7%9A%84-session-%E6%96%87%E4%BB%B6/</guid><description>由于 http 无状态性, 一般 MVC 可以使用session 用于存储用户信息.
&amp;lt;?php session_start(); // 开启 session, 将会生成一个 session_id, 通过 http 响应头返回给浏览器, 浏览器存储到本地的 cookie 中, 下次 http 请示会自动携带给服务端; // 同时会在服务端生成一个文件 如 sess_2rh6hq44kjbtagri2r88dj16b1 (后面一串为 session_id), 当前会话(通过 id保持) 的数据, 会保存在该文件中, 如 session(&amp;#39;name&amp;#39;, &amp;#39;test&amp;#39;) session_unset(); // 注销当前会话下的 session 变量, 但不会删除当前 sess_xxxx... 文件, 而是清空文件里的内容(key: value)</description></item><item><title>composer-version-constraint</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/composer-version-constraint/</link><pubDate>Fri, 15 May 2020 09:26:13 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/composer-version-constraint/</guid><description>Tilde ~2.1, means 2.1.0 &amp;lt;= version &amp;lt; 3.0.0 ~2.1.1, means 2.1.1 &amp;lt;= version &amp;lt; 2.2.0 Caret // - ^2.1, means 2.1.0 &amp;lt;= version &amp;lt; 3.0.0
^2.1.1, means 2.1.0 &amp;lt;= version &amp;lt; 3.0.0 Wildcard 2.1.*, means 2.1.0 &amp;lt;= version &amp;lt; 2.2.0 reference: composer</description></item><item><title>array_filter-过滤数组中值为空的元素</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/array_filter-%E8%BF%87%E6%BB%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%80%BC%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%85%83%E7%B4%A0/</link><pubDate>Thu, 29 Aug 2019 11:21:16 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/array_filter-%E8%BF%87%E6%BB%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%80%BC%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%85%83%E7%B4%A0/</guid><description>array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) : array 通过回调函数返回 true 返回过滤数组中的单元, 组成新数组并最终返回
如果, callable 为空, 则默认过滤数组中等值为 false 的单元(如 null, &amp;lsquo;&amp;rsquo;, &amp;rsquo; &amp;lsquo;, 0) 等</description></item><item><title>php-二维数据排序</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E4%BA%8C%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 13 Jun 2019 09:17:11 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E4%BA%8C%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/</guid><description>&amp;lt;?php $arr = [ [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 3, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 5, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 2, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 4, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], [ &amp;#39;aaifdddk&amp;#39; =&amp;gt; 1, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;test8&amp;#39;, ], ]; //usort($arr,function ($a,$b){ // return $a[&amp;#39;id&amp;#39;] &amp;gt; $b[&amp;#39;id&amp;#39;] ? 1 : -1; //}); array_multisort($arr); var_dump($arr);</description></item><item><title>php-json_encode-报错-Malformed-UTF-8-characters</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-json_encode-%E6%8A%A5%E9%94%99-malformed-utf-8-characters/</link><pubDate>Wed, 22 May 2019 15:10:19 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-json_encode-%E6%8A%A5%E9%94%99-malformed-utf-8-characters/</guid><description>当使用了 substr() 进行字符串切割后, 再进行 json_encode() 时, 报错
改使用 mb_substr() 即可
原因: substr 按字节数进行截取产生了特殊字符, 而 mb_substr 按字符数截取, 则没有问题</description></item><item><title>php-substr-截取中文出乱码</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-substr-%E6%88%AA%E5%8F%96%E4%B8%AD%E6%96%87%E5%87%BA%E4%B9%B1%E7%A0%81/</link><pubDate>Tue, 21 May 2019 17:02:59 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-substr-%E6%88%AA%E5%8F%96%E4%B8%AD%E6%96%87%E5%87%BA%E4%B9%B1%E7%A0%81/</guid><description>使用 mb_substr 解决即可,
mb_substr 按字符来截取 而 substr 按字节来截取</description></item><item><title>php文件上传临时目录</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95/</link><pubDate>Thu, 16 May 2019 14:57:47 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95/</guid><description>问题: 在上传表单中, 用户没有继续进行保存下去, 那么图片(或文件)会一直保存下去 ?
在 php.ini 中, php官方文档 (语言参考-&amp;gt;特点-&amp;gt;文件上传处理-&amp;gt;post方法上传):
文件被上传后，默认地会被储存到服务端的默认临时目录中，除非 php.ini 中的 upload_tmp_dir 设置为其它的路径。服务端的默认临时目录可以通过更改 PHP 运行环境的环境变量 TMPDIR 来重新设置，但是在 PHP 脚本内部通过运行 putenv() 函数来设置是不起作用的。该环境变量也可以用来确认其它的操作也是在上传的文件上进行的。
了解Redis过期策略及实现原理. 我们在使用redis时，一般会设置一个过期时间，当然也有不设置过期时间的，也就是永久不过期。
当我们设置了过期时间，redis是如何判断是否过期，以及根据什么策略来进行删除的。
redis设置过期时间： expire key time(以秒为单位)–这是最常用的方式 setex(String key, int seconds, String value)–字符串独有的方式
除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间
如果没有设置时间，那缓存就是永不过期
如果设置了过期时间，之后又想让缓存永不过期，使用persist key
三种过期策略 定时删除 含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除 优点：保证内存被尽快释放 缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key. 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重 懒汉式式删除 含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null。 优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了） 缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存） 定期删除 含义：每隔一段时间执行一次删除过期key操作 优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点 缺点：在内存友好方面，不如”定时删除”（会造成一定的内存占用，但是没有懒汉式那么占用内存） 在CPU时间友好方面，不如”懒汉式删除”（会定期的去进行比较和删除操作，cpu方面不如懒汉式，但是比定时好） 难点：合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了），每次执行时间太长，或者执行频率太高对cpu都是一种压力。每次进行定期删除操作执行之后，需要记录遍历循环到了哪个标志位，以便下一次定期时间来时，从上次位置开始进行循环遍历 说明：memcached只是用了惰性删除，而redis同时使用了惰性删除与定期删除，这也是二者的一个不同点（可以看做是redis优于memcached的一点）；对于懒汉式删除而言，并不是只有获取key的时候才会检查key是否过期，在某些设置key的方法上也会检查（eg.setnx key2 value2：该方法类似于memcached的add方法，如果设置的key2已经存在，那么该方法返回false，什么都不做；如果设置的key2不存在，那么该方法设置缓存key2-value2。假设调用此方法的时候，发现redis中已经存在了key2，但是该key2已经过期了，如果此时不执行删除操作的话，setnx方法将会直接返回false，也就是说此时并没有重新设置key2-value2成功，所以对于一定要在setnx执行之前，对key2进行过期检查）。 Redis采用的过期策略 懒汉式删除+定期删除 懒汉式删除流程：
在进行get或setnx等操作时，先检查key是否过期； 若过期，删除key，然后执行相应操作； 若没过期，直接执行相应操作； 定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key） 遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16） 检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体是下边的描述） 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。 对于定期删除，在程序中有一个全局变量current_db来记录下一个将要遍历的库，假设有16个库，我们这一次定期删除遍历了10个，那此时的current_db就是11，下一次定期删除就从第11个库开始遍历，假设current_db等于15了，那么之后遍历就再从0号库开始（此时current_db==0）</description></item><item><title>lnmp-环境中-使用-system-函数被报安全因素无法启用</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/lnmp-%E7%8E%AF%E5%A2%83%E4%B8%AD-%E4%BD%BF%E7%94%A8-system-%E5%87%BD%E6%95%B0%E8%A2%AB%E6%8A%A5%E5%AE%89%E5%85%A8%E5%9B%A0%E7%B4%A0%E6%97%A0%E6%B3%95%E5%90%AF%E7%94%A8/</link><pubDate>Tue, 02 Apr 2019 09:43:30 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/lnmp-%E7%8E%AF%E5%A2%83%E4%B8%AD-%E4%BD%BF%E7%94%A8-system-%E5%87%BD%E6%95%B0%E8%A2%AB%E6%8A%A5%E5%AE%89%E5%85%A8%E5%9B%A0%E7%B4%A0%E6%97%A0%E6%B3%95%E5%90%AF%E7%94%A8/</guid><description>原因: 要在 php 中使用 mysqldump 进行数据库备份 在本地 wamp 环境中使用没有问题 在线上 lnmp 环境下报错 system 函数无法使用
解决办法:
查看线上 php.ini 文件是否开启 safe_mode (安全模式); 2.1.1 如果开启了 安全模式, 则查看 disable_function 是否禁用了 system 函数 2.1.2 如果 disable_function 是禁用了 system 函数, 那么取消禁用, 并在 safe_mode_exec_dir 中添加一个包含要执行命令的目录
2.2.1 如果未开户安全模式, 直接查看 disable_function 是否禁用了 system 函数, 取消掉即可</description></item><item><title>php-json_decode-函数</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-json_decode-%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 26 Mar 2019 17:13:41 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-json_decode-%E5%87%BD%E6%95%B0/</guid><description>json_decode 把 json 字符串转成 object 或 array
$str = &amp;#39;{&amp;#34;id&amp;#34;:1, &amp;#34;name&amp;#34;:&amp;#34;hello&amp;#34;}&amp;#39;; $obj = json_decode($str); // 转成对象 $arr = json_decode($str, true);// 转成数组 // 要求 // json 字符串中的键值必须用 双引号(&amp;#34;&amp;#34;) 包裹起来, 单引号或者不用引号都不能正确解析, 结果会是 null</description></item><item><title>php-trait-的优先级</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-trait-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</link><pubDate>Tue, 22 Jan 2019 21:04:44 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-trait-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</guid><description>&amp;lt;?php trait Demo1{ public function test(){ return __METHOD__; } } trait Demo2{ public function test(){ return __METHOD__; } } class Demo0{ public function test(){ return __METHOD__; } } class Demo extends Demo0{ use Demo1,Demo2{ Demo1::test insteadof Demo2; // tait1中的test方法优先于trait2中的test方法(如果不这么设置,同名的方法会导致报错) Demo2::test as demo2test; // trait2 的test方法别名为 trait2test } } $obj = new demo(); $obj-&amp;gt;test();// Demo1::test $obj-&amp;gt;demo2test();// Demo2::test trait ,当前类,父类优先级: 当前类方法 &amp;gt; trait 的方法 &amp;gt; 父类的方法 如果当前类引用了两个 trait, 并且这两个 trait 中有同名方法,则会报错, 可以使用 insteadof 指定使用哪个trait的方法, 此外还可以用 as 来设置别名, 从而供当前类使用</description></item><item><title>正则表达式-cheat-sheet-from-github</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-cheat-sheet-from-github/</link><pubDate>Mon, 21 Jan 2019 14:59:34 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-cheat-sheet-from-github/</guid><description>转载自: https://github.com/niklongstone/regular-expression-cheat-sheet.git
Regular Expression Cheat Sheet - PCRE Anchor Description Example Valid match Invalid ^ start of string or line ^foam foam bath foam \A start of string in any match mode \Afoam foam bath foam $ end of string or line finish$ finish finnish \Z end of string, or char before last new line in any match mode finish\Z finish finnish \z end of string, in any match mode.</description></item><item><title>openssl-加密函数</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/openssl-%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0/</link><pubDate>Thu, 17 Jan 2019 13:29:20 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/openssl-%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0/</guid><description>后台使用密码保存时, 使用 md5, 不可解密;
如今想给一个登录 token 加密, 原始做法是用 md5+一定数量的字符串, 并且在缓存(或数据库)中保存这个键值对;
如果不想在后台保存 token 信息, 可以把 token信息(包括过期时间,用户账号等) 使用 open_ssl 加密, 然后要在后台要验证的时候, 再解密出来
例如
&amp;lt;?php $key = &amp;#39;key123456789&amp;#39;;//加密字符串的密码, 类似于md5加盐 $method = &amp;#39;AES-128-CBC&amp;#39;;// 加密方法 $arr = [&amp;#39;user_id&amp;#39;=&amp;gt;1, &amp;#39;expire_time&amp;#39;=&amp;gt;60*60]; // 用户id为1, 有效期为1h $str = json_encode($arr); $secret_str = openssl_encrypt($str,$method,$key);// 加密字符串 $secret_str = urlencode($secret_str);// 加密字符串 var_dump($secret_str);// jRX%2BtqOyhHVOzHX7cFI0usMUs7qKH4uEaOqKkdBQ2A08C1FmRRGXWFBfCleJPu3i $origin_str = urldecode($secret_str); $origin_str = openssl_decrypt($origin_str,$method,$key);// 解密字符串 var_dump($origin_str);// {&amp;#34;user_id&amp;#34;:1,&amp;#34;expire_time&amp;#34;:3600} var_dump(json_decode($origin_str));// [&amp;#34;user_id&amp;#34;=&amp;gt;1,&amp;#34;expire_time&amp;#34;=&amp;gt;3600] // 加密 openssl_encrypt ( string $data , string $method , string $key [, int $options = 0 [, string $iv = &amp;#34;&amp;#34; [, string &amp;amp;$tag = NULL [, string $aad = &amp;#34;&amp;#34; [, int $tag_length = 16 ]]]]] ) : string // 解密 openssl_decrypt ( string $data , string $method , string $key [, int $options = 0 [, string $iv = &amp;#34;&amp;#34; [, string $tag = &amp;#34;&amp;#34; [, string $aad = &amp;#34;&amp;#34; ]]]] ) : string // data // The encrypted message to be decrypted.</description></item><item><title>nginx-反向代理</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link><pubDate>Wed, 16 Jan 2019 13:43:33 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid><description>正向代理是 客户端向指定的服务器发起请求, 客户是隐藏的;
反向代理, 则是隐藏了多个服务器, 由代理服务器决定向(集群服务器组)哪个服务器发起请求
参考自: https://blog.csdn.net/tsummerb/article/details/79248015</description></item><item><title>phpqrcode-生成的图片转为-base64-格式输出</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/phpqrcode-%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E4%B8%BA-base64-%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA/</link><pubDate>Thu, 10 Jan 2019 22:20:42 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/phpqrcode-%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E4%B8%BA-base64-%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA/</guid><description>原文见: https://www.pusonglin.cn/work/1619.html
项目中需要用到phpqrcode生成二维码，但是通过QRcode::png()生成的是显示输出当前的照片流，这样就不适用于列表显示多个二维码的需求了。网上也有相关的一些解决方案:通过把照片流缓存，然后进行base64编码。
找到生成图片用到了QRimage类的png方法，去除里面的：Header(“Content-type: image/png”);即可。
class QRimage { //---------------------------------------------------------------------- public static function png($frame, $filename = false, $pixelPerPoint = 4, $outerFrame = 4,$saveandprint=FALSE) { $image = self::image($frame, $pixelPerPoint, $outerFrame); if ($filename === false) { // Header(&amp;#34;Content-type: image/png&amp;#34;); ImagePng($image); } else { if($saveandprint===TRUE){ ImagePng($image, $filename); header(&amp;#34;Content-type: image/png&amp;#34;); ImagePng($image); }else{ ImagePng($image, $filename); } } ImageDestroy($image); } 如此，不再让输出端整个页面变为图片类型，解决方案并不完美，但是能达到我的目的即可。 附调用端代码：
&amp;lt;?php global $_W,$_GPC; function getqrcode($url){ require_once MODULE_ROOT.&amp;#39;/lib/phpqrcode_web.php&amp;#39;; $value = $url; //二维码内容 $errorCorrectionLevel = &amp;#39;L&amp;#39;; //容错级别 $matrixPointSize = 5; //生成图片大小 //生成二维码图片 ob_start(); QRcode::png($value,false,$errorCorrectionLevel, $matrixPointSize, 2); $imgstr = base64_encode(ob_get_contents()); ob_end_clean(); return $imgstr; } //调用查看结果 include $this-&amp;gt;template(&amp;#39;web/test&amp;#39;); ?</description></item><item><title>正则表达式-----必须含有大写字母和数字</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-----%E5%BF%85%E9%A1%BB%E5%90%AB%E6%9C%89%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97/</link><pubDate>Thu, 10 Jan 2019 13:36:05 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-----%E5%BF%85%E9%A1%BB%E5%90%AB%E6%9C%89%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97/</guid><description>原文见:https://blog.csdn.net/u011974797/article/details/71479456
要求：由数字和字母组成，并且要同时含有数字和字母，且长度要在8-16位之间。
^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8,16}$
分开来注释一下： ^ 匹配一行的开头位置 (?![0-9]+$) 预测该位置后面不全是数字 (?![a-zA-Z]+$) 预测该位置后面不全是字母 [0-9A-Za-z] {8,16} 由8-16位数字或这字母组成 $ 匹配行结尾位置
注：(?!xxxx) 是正则表达式的负向零宽断言一种形式，标识预该位置后不是xxxx字符。
附：
要求：可以包含数字、字母、下划线，并且要同时含有数字和字母，且长度要在8-16位之间。 ^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z_]{8,16}$</description></item><item><title>restful--patch-和-put-请求的区别</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/restful--patch-%E5%92%8C-put-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 01 Sep 2018 20:34:49 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/restful--patch-%E5%92%8C-put-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>看到 laravel 使用 Route::resource 生成 restful 架构的路由, 里面的更新用的是 patch 请求, 而有的地方说是用 put, 就查了一下, 这篇说得很明白, 就复制过来了
put 更新全部资源 patch 方法用来更新局部资源 假设我们有一个UserInfo，里面有userId， userName， userGender等10个字段。可你的编辑功能因为需求，在某个特别的页面里只能修改userName，这时候的更新怎么做？
人们通常(为徒省事)把一个包含了修改后userName的完整userInfo对象传给后端，做完整更新。但仔细想想，这种做法感觉有点二，而且真心浪费带宽(纯技术上讲，你不关心带宽那是你土豪)。
于是patch诞生，只传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段。
而put虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象，理论上说，如果你用了put，但却没有提供完整的UserInfo，那么缺了的那些字段应该被清空
原文见 https://blog.csdn.net/mysevenyear/article/details/80674080</description></item><item><title>laravel-学习笔记1_20180829</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01_20180829/</link><pubDate>Wed, 29 Aug 2018 10:12:07 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/laravel-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01_20180829/</guid><description>######1. 在修改完 Homestead.yaml 文件后, 需要在本机加载并重启 vagrant, 执行如下
&amp;gt; vagrant provision &amp;amp;&amp;amp; vagrant reload ######2. git 初始化(保存到本地), 设置远程仓库及使用默认远程仓库
$ git init $ git add -A $ git commit -m &amp;#34;Initial commit&amp;#34; $ git remote add origin git@github.com:&amp;lt;user_name&amp;gt;/&amp;lt;repositoy_name&amp;gt;.git $ git push -u origin master 其中, origin 作为默认的远程仓库服务器名 ( 也可以改成别的 ), &amp;lt;user_name&amp;gt; 指的是 git 中的用户名, &amp;lt;repositoy_name&amp;gt; 指的是 git 中的仓库名
git push -u origin master 意为将本地 master 分支推送到 origin 远程仓库; 其中 -u 指的是将 origin 和 master 连接起来, 以后即可以直接使用 git push 则代表推送 master 到 origin</description></item><item><title>用-uploadifive-插件上传文件时的问题</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E7%94%A8-uploadifive-%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 20 May 2018 17:33:38 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E7%94%A8-uploadifive-%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>官方文档错误 fileType 的值是 &amp;lsquo;fileType&amp;rsquo;: &amp;lsquo;image&amp;rsquo; 而不能是 &amp;lsquo;fileType&amp;rsquo;: &amp;lsquo;image/*&amp;rsquo;
后台用tp5框架时, 返回值如果是数组,则要通过json_encode [ 或者tp5 的 json ]函数进行转码, 而不能直接 return[即使配置文件中设置了 &amp;lsquo;default_return_type&amp;rsquo; =&amp;gt; &amp;lsquo;json&amp;rsquo;,] 否则会出现错误</description></item><item><title>phpstorm-快捷生成函数的注释</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/phpstorm-%E5%BF%AB%E6%8D%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E9%87%8A/</link><pubDate>Wed, 16 May 2018 23:46:17 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/phpstorm-%E5%BF%AB%E6%8D%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E9%87%8A/</guid><description>在函数上一行键入 /**
/** * @param $a * @param $b * @return mixed */ function abc($a, $b) { $c = $a + $b; return $c; } 然后 enter 回车即可</description></item><item><title>php-正则匹配中文</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87/</link><pubDate>Tue, 15 May 2018 18:56:14 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87/</guid><description>php正则匹配汉字!
$reg = &amp;lsquo;/^[\x{4e00}-\x{9fa5}]+$/u&amp;rsquo;;
而不是 $reg = &amp;lsquo;/^[\u4e00-\u9fa5]+$/u&amp;rsquo;;</description></item><item><title>thinkphp5-模板渲染-在控制器中不能-少了return</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93-%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E4%B8%8D%E8%83%BD-%E5%B0%91%E4%BA%86return/</link><pubDate>Thu, 26 Apr 2018 18:00:40 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93-%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E4%B8%8D%E8%83%BD-%E5%B0%91%E4%BA%86return/</guid><description>namespace module\controller; use think\Controller; class index extends Controller { public function index{ return this-&amp;gt;view-&amp;gt;fetch(&amp;#39;index&amp;#39;); } }</description></item><item><title>ThinkPHP5-对无限分类数组进行分页显示</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-%E5%AF%B9%E6%97%A0%E9%99%90%E5%88%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E6%98%BE%E7%A4%BA/</link><pubDate>Thu, 26 Apr 2018 11:16:20 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/thinkphp5-%E5%AF%B9%E6%97%A0%E9%99%90%E5%88%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E6%98%BE%E7%A4%BA/</guid><description>use think\Controller; use think\paginator\driver\Bootstrap; class Category extends Controller { public function index2() { // 1.获取要分页的数组 $cate = CategoryModel::getCate();// 无限分类后的数组 $data = $cate; // 1.1 设置当前分页(从url get方式获取), 每页显示记录行数 $curPage = input(&amp;#39;page&amp;#39;) ? input(&amp;#39;page&amp;#39;) : 1; $listRow = 3; // 1.2 得到当前分页所要显示的数组(array_chunk 或 array_slice 函数) $showData = array_chunk($data, $listRow, true); $showData = $showData[$curPage - 1]; // $showData = array_slice($data, ($curPage - 1) * $listRow, $listRow, true); // 1.3 调用Bootstrap类方法生成分页对象 $p = Bootstrap::make($showData, $listRow, $curPage, count($data), false, [ &amp;#39;var_page&amp;#39; =&amp;gt; &amp;#39;page&amp;#39;, &amp;#39;path&amp;#39; =&amp;gt; url(&amp;#39;category/index2&amp;#39;), // 这里根据需要修改url &amp;#39;query&amp;#39; =&amp;gt; [], &amp;#39;fragment&amp;#39; =&amp;gt; &amp;#39;&amp;#39;, ]); $p-&amp;gt;appends($_GET); // 添加URL参数 // 2.</description></item><item><title>在弹窗通过layer插件打开的情况下，采用jQuery-Ajax提交表单后，弹窗无法关闭</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%9C%A8%E5%BC%B9%E7%AA%97%E9%80%9A%E8%BF%87layer%E6%8F%92%E4%BB%B6%E6%89%93%E5%BC%80%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%87%E7%94%A8jquery-ajax%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E5%90%8E%E5%BC%B9%E7%AA%97%E6%97%A0%E6%B3%95%E5%85%B3%E9%97%AD/</link><pubDate>Tue, 24 Apr 2018 20:08:57 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%9C%A8%E5%BC%B9%E7%AA%97%E9%80%9A%E8%BF%87layer%E6%8F%92%E4%BB%B6%E6%89%93%E5%BC%80%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%87%E7%94%A8jquery-ajax%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E5%90%8E%E5%BC%B9%E7%AA%97%E6%97%A0%E6%B3%95%E5%85%B3%E9%97%AD/</guid><description>原文地址:https://blog.csdn.net/cc_niu/article/details/77949829
自己代码:
&amp;lt;script&amp;gt; jQuery(&amp;#34;#updatebtn&amp;#34;).click(function () { jQuery.ajax({ type: &amp;#39;POST&amp;#39;, url: &amp;#34;&amp;lt;{:url(&amp;#39;admin/admin/update&amp;#39;)}&amp;gt;&amp;#34;, data: jQuery(&amp;#34;.layui-form&amp;#34;).serialize(), dataType: &amp;#39;json&amp;#39;, success: function (data) { if (data.status == 1) { // 成功返回 alert(data.message); // 刷新父级窗口,即可关闭当前窗口 window.parent.location.reload(); } else { // 失败返回 alert(data.message); window.location.href = &amp;#34;&amp;lt;{:url(&amp;#39;admin/edit&amp;#39;)}&amp;gt;&amp;#34;; } } }) }); &amp;lt;/script&amp;gt;</description></item><item><title>jQuery-AJAX-提交表单信息时,提交按钮不能为-submit</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/jquery-ajax-%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E4%BF%A1%E6%81%AF%E6%97%B6%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E4%B8%8D%E8%83%BD%E4%B8%BA-submit/</link><pubDate>Tue, 24 Apr 2018 19:17:50 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/jquery-ajax-%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E4%BF%A1%E6%81%AF%E6%97%B6%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E4%B8%8D%E8%83%BD%E4%B8%BA-submit/</guid><description>ajax代码:
&amp;lt;script&amp;gt; jQuery(&amp;#34;#btn&amp;#34;).click(function () { jQuery.ajax({ type: &amp;#39;POST&amp;#39;, url: &amp;#34;&amp;lt;{:url(&amp;#39;admin/admin/update&amp;#39;)}&amp;gt;&amp;#34;, data: jQuery(&amp;#34;form&amp;#34;).serialize(), dataType: &amp;#39;json&amp;#39;, success: function (data) { if (data.status == 1) { alert(data.message); // window.location.href = &amp;#34;&amp;lt;{:url(&amp;#39;admin/index&amp;#39;)}&amp;gt;&amp;#34;; } else { alert(data.message); // window.location.href = &amp;#34;&amp;lt;{:url(&amp;#39;admin/edit&amp;#39;)}&amp;gt;&amp;#34;; } } }) }); &amp;lt;/script&amp;gt; html文件可以是:
&amp;lt;input type=&amp;#34;button&amp;#34; id=&amp;#34;btn0&amp;#34; value=&amp;#34;保存&amp;#34;&amp;gt; &amp;lt;button type=&amp;#34;button&amp;#34; id=&amp;#34;btn1&amp;#34;&amp;gt;保存&amp;lt;/button&amp;gt; &amp;lt;a&amp;gt;保存&amp;lt;/a&amp;gt;</description></item><item><title>php路径</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 19 Mar 2018 18:14:04 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E8%B7%AF%E5%BE%84/</guid><description>/ 代表服务器根目录 ./ 代表当前同一级目录 ../ 代表上一级目录</description></item><item><title>PHP封装一个自己的my_parse_ini_file()</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84my_parse_ini_file/</link><pubDate>Tue, 30 Jan 2018 22:30:33 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/php%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84my_parse_ini_file/</guid><description>PHP文件提取练习[parse_ini_file() ] ： 编写一个自己的 my_parse_ini_file() ，完成对 .ini 文件的读取 提示: explode 分割字符串 / fgets 读取一行数据 &amp;lt;?php function my_parse_ini_file($dir) { if (!file_exists($dir)) { echo &amp;#39;文件不存在, 无法访问&amp;#39;; return FALSE; } else { $fsize = filesize($dir); $fp = fopen($dir, &amp;#39;r&amp;#39;); $con_str = fread($fp, $fsize); // 把字符串中的空白字符&amp;#39; &amp;#39;替换为&amp;#39;&amp;#39;, 也就是删除空白字符 $con_str = str_replace(&amp;#39; &amp;#39;, &amp;#39;&amp;#39;, $con_str); // 按回车换行给字符串分割成数组 $arr_temp1 = explode(&amp;#34;\r\n&amp;#34;, $con_str); $arr_res = array(); foreach ($arr_temp1 as $value) { $arr_temp2 = explode(&amp;#39;=&amp;#39;, $value); $arr_res[$arr_temp2[0]] = $arr_temp2[1]; } return $arr_res; } } $file_full_path = &amp;#39;e:/config.</description></item><item><title>双引号和单引号----由sql语句中的字符串变量而来</title><link>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8D%95%E5%BC%95%E5%8F%B7----%E7%94%B1sql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E8%80%8C%E6%9D%A5/</link><pubDate>Fri, 12 Jan 2018 13:43:35 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/backend/%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8D%95%E5%BC%95%E5%8F%B7----%E7%94%B1sql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E8%80%8C%E6%9D%A5/</guid><description>在用php操作mysql 表的时候,遇到一个问题 表结构: CREATE TABLE news ( id int(10) unsigned NOT NULL AUTO_INCREMENT, title varchar(50) DEFAULT NULL, content text, add_time int(11) DEFAULT NULL, PRIMARY KEY (id) );
写了条sql语句
结果第一条可以正确显示,第二条却出错
原因在于title字段类型是字符串,所以其中的变量要用引号引起来 也就是 $sql2 = &amp;ldquo;SELECT * FROM news WHERE title=&amp;rsquo;$title&amp;rsquo;&amp;rdquo;;
由此举例php中单双引号的使用情况如下:</description></item></channel></rss>