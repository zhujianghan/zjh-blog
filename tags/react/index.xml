<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>react on My New Hugo Site</title><link>https://zhujianghan.github.io/zjh-blog/tags/react/</link><description>Recent content in react on My New Hugo Site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 23 Sep 2020 15:21:44 +0800</lastBuildDate><atom:link href="https://zhujianghan.github.io/zjh-blog/tags/react/index.xml" rel="self" type="application/rss+xml"/><item><title>redux-的-reducer-函数不能改变原-state</title><link>https://zhujianghan.github.io/zjh-blog/posts/frontend/redux-%E7%9A%84-reducer-%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%94%B9%E5%8F%98%E5%8E%9F-state/</link><pubDate>Wed, 23 Sep 2020 15:21:44 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/frontend/redux-%E7%9A%84-reducer-%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%94%B9%E5%8F%98%E5%8E%9F-state/</guid><description>可以使用如下方法来完全复制原来的 state, 再进行操作
对于数组: concat, slice, 或 spread operator 对于对象: Object.assign 或 spread operator 参考 valentinog.com</description></item><item><title>Pure-Fuction-纯函数的定义</title><link>https://zhujianghan.github.io/zjh-blog/posts/frontend/pure-fuction-%E7%BA%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/</link><pubDate>Wed, 23 Sep 2020 10:53:16 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/frontend/pure-fuction-%E7%BA%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/</guid><description>Pure Function wiki definition:
In computer programming a pure function is a that has the following properties:
Its return value is the same for the same arguments. Its evaluation has no side effects. 同样参数总是返回相同的结果, 也就是函数内部没有随机生成的数 没有副作用, 指的是不会改变其它的变量的值, 不会有日志记录等 redux 的 reducer 中使用 纯函数, 输入一个 state, 在不改变输入的 state 的情况下, 返回一个 新的 state</description></item><item><title>webstorm-不提示-react-router-dom-中的-hooks(useRouteMatch-)</title><link>https://zhujianghan.github.io/zjh-blog/posts/frontend/webstorm-%E4%B8%8D%E6%8F%90%E7%A4%BA-react-router-dom-%E4%B8%AD%E7%9A%84-hooksuseroutematch-/</link><pubDate>Thu, 17 Sep 2020 10:12:45 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/frontend/webstorm-%E4%B8%8D%E6%8F%90%E7%A4%BA-react-router-dom-%E4%B8%AD%E7%9A%84-hooksuseroutematch-/</guid><description>现象: import { BrowserRouter, Switch, // 不提示 Route, // 不提示 NavLink, useRouteMatch // 不提示 } from &amp;#39;react-router-dom&amp;#39; 原因: // react-router-dom.js export { MemoryRouter, Prompt, Redirect, Route, Router, StaticRouter, Switch, generatePath, matchPath, useHistory, useLocation, useParams, useRouteMatch, withRouter } from &amp;#39;react-router&amp;#39;; Switch, Route, useRouteMatch &amp;hellip; 这类组件(或函数) 不是真正存在于 react-router-dom.js 文件中, 而是存在于 react-router.js 中导致 WebStorm 没有识别出来.
解决办法: 在 package.json 文件的 dependencies 加入 react-router &amp;#34;react-router&amp;#34;: &amp;#34;^5.2.0&amp;#34;, // 加入此行 &amp;#34;react-router-dom&amp;#34;: &amp;#34;^5.2.0&amp;#34;, 参考自 stackoverflow: Why does IntelliJ does not auto import react router hooks?</description></item><item><title>react-router-中-path-和-url-的关系</title><link>https://zhujianghan.github.io/zjh-blog/posts/frontend/react-router-%E4%B8%AD-path-%E5%92%8C-url-%E7%9A%84%E5%85%B3%E7%B3%BB/</link><pubDate>Wed, 16 Sep 2020 13:37:31 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/frontend/react-router-%E4%B8%AD-path-%E5%92%8C-url-%E7%9A%84%E5%85%B3%E7%B3%BB/</guid><description>// jsx let match = useRouteMatch() console.log(match) // isExact: true // params: {topicId: &amp;#34;6&amp;#34;} // path: &amp;#34;/topics/:topicId&amp;#34; // url: &amp;#34;/topics/6&amp;#34; 在动态路由中 其中, path 指的是路由的名称, 路径; url 指的是当前页面真实的地址, 也就是地址栏中显示的 url
在非动态路由中, 二者是一样的</description></item><item><title>react-把一个组件的-props-全部传给子组件</title><link>https://zhujianghan.github.io/zjh-blog/posts/frontend/react-%E6%8A%8A%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84-props-%E5%85%A8%E9%83%A8%E4%BC%A0%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6/</link><pubDate>Wed, 16 Sep 2020 10:32:00 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/frontend/react-%E6%8A%8A%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84-props-%E5%85%A8%E9%83%A8%E4%BC%A0%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6/</guid><description>背景: 自定义了一个 MyNavLink, 统一修改了 activeClassName, 其它属性由 MyNavLink 转发到 NavLink
// 定义组件 function MyNavLink(props) { return &amp;lt;NavLink activeClassName=&amp;#39;my-active&amp;#39; {...props}/&amp;gt; } // 使用 &amp;lt;MyNavLink to=&amp;#39;/home&amp;#39; className=&amp;#39;link&amp;#39;}&amp;gt;a link&amp;lt;/MyNavLink&amp;gt; 关键: 使用 ... 对 props 进行解构</description></item><item><title>taro-alias</title><link>https://zhujianghan.github.io/zjh-blog/posts/frontend/taro-alias/</link><pubDate>Thu, 09 Jul 2020 09:27:08 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/frontend/taro-alias/</guid><description>官方文档: https://taro-docs.jd.com/taro/docs/config-detail 还要引入 path
const path = require(&amp;#39;path&amp;#39;) // 此步骤不能少 const config = { . . . alias: { &amp;#39;@/components&amp;#39;: path.resolve(__dirname, &amp;#39;..&amp;#39;, &amp;#39;src/components&amp;#39;), &amp;#39;@/utils&amp;#39;: path.resolve(__dirname, &amp;#39;..&amp;#39;, &amp;#39;src/utils&amp;#39;), &amp;#39;@/assets&amp;#39;: path.resolve(__dirname, &amp;#39;..&amp;#39;, &amp;#39;src/assets&amp;#39;), &amp;#39;@/static&amp;#39;: path.resolve(__dirname, &amp;#39;..&amp;#39;, &amp;#39;src/static&amp;#39;) }, . . . }</description></item><item><title>多个-eventListener,-如何取消</title><link>https://zhujianghan.github.io/zjh-blog/posts/frontend/%E5%A4%9A%E4%B8%AA-eventlistener-%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88/</link><pubDate>Wed, 08 Jul 2020 23:35:08 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/frontend/%E5%A4%9A%E4%B8%AA-eventlistener-%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88/</guid><description>参考: JavaScript事件机制
背景: 在 taro3.0.2 中, 小程序端使用 onPullDown(), 会造成 h5 端可以下拉, 但是不正常(顶部出现下拉空白, 不可恢复)
后来发现 tao-tabbar__pannel 的 touchmove 事件造成的 于是要关闭这个事件, 但是 使用 removeEventListener 不管用, 使用 addEventListener 覆盖, 会发现会依次执行, 不会覆盖, 于是就有了参考文章里的方法 e.stopImmediatePropagation()
async componentDidMount() { // h5 不支持下拉刷新, 下拉会出现空白, 且不消失 if (process.env.TARO_ENV === &amp;#39;h5&amp;#39;) { const obj = document.getElementsByClassName(&amp;#39;taro-tabbar__panel&amp;#39;) obj[0].addEventListener(&amp;#39;touchmove&amp;#39;, function (e) { e.stopImmediatePropagation() e.preventDefault() }) } . . . }</description></item><item><title>react-render(),-组件名</title><link>https://zhujianghan.github.io/zjh-blog/posts/frontend/react-render-%E7%BB%84%E4%BB%B6%E5%90%8D/</link><pubDate>Thu, 02 Jul 2020 14:59:54 +0800</pubDate><guid>https://zhujianghan.github.io/zjh-blog/posts/frontend/react-render-%E7%BB%84%E4%BB%B6%E5%90%8D/</guid><description>render 方法中只能有一个 顶级父元素
// 正确 render() { &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;1111&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;2222&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; } // 错误 render() { &amp;lt;p&amp;gt;1111&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;2222&amp;lt;/p&amp;gt; } 组件类名及 html 标签 的名称必须 首字母大写</description></item></channel></rss>